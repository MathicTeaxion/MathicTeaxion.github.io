<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2023牛客寒假算法基础集训营1补题记</title>
    <url>/2023/05/03/2023%E7%89%9B%E5%AE%A2%E5%AF%92%E5%81%87%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E9%9B%86%E8%AE%AD%E8%90%A51%E8%A1%A5%E9%A2%98%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>A_简单前后缀模拟，B_四维dp（…），C_简单贪心，D_给出的初始矩形，大体把平面分为了四个部分每一个部分讨论一下取最大值，E_利用叉积判断第三个操作是否一定用过，F_连通块利用并查集DSU，G_维护到叶子结点的线段树不需要懒标记，H_用整个大的减去剩余块的成本，K_dp或者贪心构造，L_期望计算，M_手推方程</p>
<span id="more"></span>
<h2 id="官方题目难度排名"><a href="#官方题目难度排名" class="headerlink" title="官方题目难度排名"></a>官方题目难度排名</h2><div align=left><img src="https://s2.loli.net/2023/02/05/IBXZvqT8NC1wWQb.png" width="251" height="350" ></div>

<h2 id="A-World-Final-World-Cup-I"><a href="#A-World-Final-World-Cup-I" class="headerlink" title="A. World Final? World Cup! (I)"></a>A. World Final? World Cup! (I)</h2><h2 id="B-World-Final-World-Cup-II"><a href="#B-World-Final-World-Cup-II" class="headerlink" title="B. World Final? World Cup! (II)"></a>B. World Final? World Cup! (II)</h2><h2 id="C-现在是，学术时间-I"><a href="#C-现在是，学术时间-I" class="headerlink" title="C. 现在是，学术时间 (I)"></a>C. 现在是，学术时间 (I)</h2><h2 id="D-现在是，学术时间-II"><a href="#D-现在是，学术时间-II" class="headerlink" title="D. 现在是，学术时间 (II)"></a>D. 现在是，学术时间 (II)</h2><h2 id="E-鸡算几何"><a href="#E-鸡算几何" class="headerlink" title="E. 鸡算几何"></a>E. 鸡算几何</h2><h2 id="F-鸡玩炸蛋人"><a href="#F-鸡玩炸蛋人" class="headerlink" title="F. 鸡玩炸蛋人"></a>F. 鸡玩炸蛋人</h2><h2 id="G-鸡格线"><a href="#G-鸡格线" class="headerlink" title="G. 鸡格线"></a>G. 鸡格线</h2><h2 id="H-本题主要考察了DFS"><a href="#H-本题主要考察了DFS" class="headerlink" title="H. 本题主要考察了DFS"></a>H. 本题主要考察了DFS</h2><h2 id="I-本题也主要考察了DFS"><a href="#I-本题也主要考察了DFS" class="headerlink" title="I. 本题也主要考察了DFS"></a>I. 本题也主要考察了DFS</h2><h2 id="J-本题竟也主要考察了DFS"><a href="#J-本题竟也主要考察了DFS" class="headerlink" title="J.本题竟也主要考察了DFS"></a>J.本题竟也主要考察了DFS</h2><h2 id="K-本题主要考察了dp"><a href="#K-本题主要考察了dp" class="headerlink" title="K. 本题主要考察了dp"></a>K. 本题主要考察了dp</h2><h2 id="L-本题主要考察了运气"><a href="#L-本题主要考察了运气" class="headerlink" title="L. 本题主要考察了运气"></a>L. 本题主要考察了运气</h2><h2 id="M-本题主要考察了找规律"><a href="#M-本题主要考察了找规律" class="headerlink" title="M.本题主要考察了找规律"></a>M.本题主要考察了找规律</h2>]]></content>
      <categories>
        <category>算法竞赛补题记</category>
      </categories>
      <tags>
        <tag>牛客多校</tag>
      </tags>
  </entry>
  <entry>
    <title>NSSCTF_RoundXI详解与思路分享</title>
    <url>/2023/04/24/NSSCTF-RoundXI%E8%AF%A6%E8%A7%A3%E4%B8%8E%E6%80%9D%E8%B7%AF%E5%88%86%E4%BA%AB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><center>抱歉，这篇文章鸽了（</center>

<span id="more"></span>
<p><img src="https://www.nssctf.cn/files/2023/4/6/fad6f84051.png" alt=""></p>
<h1 id="Crypto"><a href="#Crypto" class="headerlink" title="Crypto"></a>Crypto</h1><h2 id="ez-enc"><a href="#ez-enc" class="headerlink" title="ez_enc"></a>ez_enc</h2><p><a href="https://www.nssctf.cn/problem/3624">题目附件链接</a></p>
<h2 id="MyMessage"><a href="#MyMessage" class="headerlink" title="MyMessage"></a>MyMessage</h2><p><a href="https://www.nssctf.cn/problem/3626">题目附件链接</a></p>
<h2 id="MyGame"><a href="#MyGame" class="headerlink" title="MyGame"></a>MyGame</h2><p><a href="https://www.nssctf.cn/problem/3627">题目附件链接</a></p>
<h2 id="ez-signin"><a href="#ez-signin" class="headerlink" title="ez_signin"></a>ez_signin</h2><p><a href="https://www.nssctf.cn/problem/3623">题目附件链接</a></p>
<h2 id="ez-fac"><a href="#ez-fac" class="headerlink" title="ez_fac"></a>ez_fac</h2><p><a href="https://www.nssctf.cn/problem/3622">题目附件链接</a></p>
<h2 id="NTR"><a href="#NTR" class="headerlink" title="NTR"></a>NTR</h2><p><a href="https://www.nssctf.cn/problem/3625">题目附件链接</a></p>
<p>​    </p>
]]></content>
      <tags>
        <tag>CTF_WriteUp</tag>
      </tags>
  </entry>
  <entry>
    <title>WriteUp_GDOUCTF的Crypto详解以及代码思路</title>
    <url>/2023/04/14/WriteUp-GDOUCTF%E7%9A%84Crypto%E8%AF%A6%E8%A7%A3%E4%BB%A5%E5%8F%8A%E4%BB%A3%E7%A0%81%E6%80%9D%E8%B7%AF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><center>抱歉，这篇文章鸽了（</center>

<span id="more"></span>
<p><img src="https://www.nssctf.cn/files/2023/4/5/2dd3efcc6a.png" alt=""></p>
<h1 id="Crypto"><a href="#Crypto" class="headerlink" title="Crypto"></a>Crypto</h1><h2 id="Absolute-Baby-Encrytpion"><a href="#Absolute-Baby-Encrytpion" class="headerlink" title="Absolute_Baby_Encrytpion"></a>Absolute_Baby_Encrytpion</h2><p><a href="https://www.nssctf.cn/problem/3675">题目附件链接</a></p>
<h2 id="babylua"><a href="#babylua" class="headerlink" title="babylua"></a>babylua</h2><p><a href="https://www.nssctf.cn/problem/3673">题目附件链接</a></p>
<h2 id="Magic-of-Encoding"><a href="#Magic-of-Encoding" class="headerlink" title="Magic of Encoding"></a>Magic of Encoding</h2><p><a href="https://www.nssctf.cn/problem/3674">题目附件链接</a></p>
<h2 id="Math-Problem"><a href="#Math-Problem" class="headerlink" title="Math Problem"></a>Math Problem</h2><p><a href="https://www.nssctf.cn/problem/3677">题目附件链接</a></p>
]]></content>
      <categories>
        <category>CTF密码学题解</category>
      </categories>
      <tags>
        <tag>Crypto_WriteUp</tag>
      </tags>
  </entry>
  <entry>
    <title>WriteUp_HDCTF2023的Crypto详解以及代码思路</title>
    <url>/2023/04/24/WriteUp-HDCTF2023%E7%9A%84Crypto%E8%AF%A6%E8%A7%A3%E4%BB%A5%E5%8F%8A%E4%BB%A3%E7%A0%81%E6%80%9D%E8%B7%AF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><center>抱歉，这篇文章鸽了（</center>

<span id="more"></span>
<p><img src="https://www.nssctf.cn/files/2023/4/18/3214386459.png" alt=""></p>
<h1 id="Crypto"><a href="#Crypto" class="headerlink" title="Crypto"></a>Crypto</h1><h2 id="Normal-Rsa-revenge"><a href="#Normal-Rsa-revenge" class="headerlink" title="Normal_Rsa(revenge)"></a>Normal_Rsa(revenge)</h2><p><a href="https://www.nssctf.cn/problem/3798">题目附件链接</a></p>
<h2 id="爬过小山去看云"><a href="#爬过小山去看云" class="headerlink" title="爬过小山去看云"></a>爬过小山去看云</h2><p><a href="https://www.nssctf.cn/problem/3766">题目附件链接</a></p>
<h2 id="Math-Rsa"><a href="#Math-Rsa" class="headerlink" title="Math_Rsa"></a>Math_Rsa</h2><p><a href="https://www.nssctf.cn/problem/3768">题目附件链接</a></p>
<h2 id="Spy-DES"><a href="#Spy-DES" class="headerlink" title="Spy_DES"></a>Spy_DES</h2><p><a href="https://www.nssctf.cn/problem/3770">题目附件链接</a></p>
]]></content>
      <categories>
        <category>CTF密码学题解</category>
      </categories>
      <tags>
        <tag>Crypto_WriteUp</tag>
      </tags>
  </entry>
  <entry>
    <title>XCPC简单实用小技巧整理</title>
    <url>/2021/06/24/base-basic/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>位运算</p>
<span id="more"></span>
<h2 id="位运算的常见应用"><a href="#位运算的常见应用" class="headerlink" title="位运算的常见应用"></a>位运算的常见应用</h2><h3 id="集合枚举"><a href="#集合枚举" class="headerlink" title="集合枚举"></a>集合枚举</h3><p>好像在状态压缩里面的集合枚举经常用到。</p>
<blockquote>
<p>比如现在有 $n$ 件物品，编号从 $1$ 到 $n$,我们可以用一个 $n$ 位二进制数来表示每个物品取或不取的状态，二进制数从右往左数第 k 位的 $01$ 状态表示编号为 $k$ 的物品取了还是没有取（$1$表示取了，$0$ 表示没有取)。</p>
</blockquote>
<p>在枚举集合进行运算的过程当中，我们经常遇到要枚举当前集合的子集或超集的情况。</p>
<ul>
<li>假设 $n = 5$ ，当前状态为 $x = (11001)_2$</li>
<li>其所有子集的二进制表示为:$11001,11000,10001,10000,01001,01000,00001,00000$</li>
<li>其所有超集的二进制表示为:$11001,11011,11101,11111$</li>
</ul>
<p>枚举所有状态的非空子集的代码如下：（ 时间复杂度为 $O( 3^n )$ ）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">1</span> &lt;&lt; n;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = i; j ; j = (j - <span class="number">1</span>) &amp; i)&#123;</span><br><span class="line">        <span class="comment">//j 遍历了 i 的所有非空子集</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>有时候我们需要根据一个数的二进制中含有 $1$ 的个数来进行集合枚举。例如，所有含有 $3$ 个 $1$ 的 $5$ 个 $bit$ 的整数（不包含符号位）可以表示如下:$00111,01011,01101,01110,10011,10101,10110,11001,11010,11100$（这里均为二进制）</p>
<p>（另）如何求出当前01序列的下一个排列呢，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x, y;<span class="comment">//x 为当前的数，y 为要求的下一个数</span></span><br><span class="line"><span class="type">int</span> t = (x | (x - <span class="number">1</span>)) + <span class="number">1</span>;<span class="comment">//把最后一段连续的1变成0，并将前一位变成1</span></span><br><span class="line">y = t | ((((t &amp; -t)/(x &amp; -x)) &gt;&gt; <span class="number">1</span>) - <span class="number">1</span>);<span class="comment">//补上少了的1的个数</span></span><br></pre></td></tr></table></figure>
<h3 id="其他小应用"><a href="#其他小应用" class="headerlink" title="其他小应用"></a>其他小应用</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">x &gt;&gt; n <span class="comment">//等价于 x * (2^n)</span></span><br><span class="line">x &lt;&lt; k <span class="comment">//等价于 x / (2^k)    ----整除</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> f = ((x ^ y) &lt; <span class="number">0</span>);</span><br><span class="line"><span class="comment">//判断两数符号是否相同</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> f = (x &amp; (x - <span class="number">1</span>)) == <span class="number">0</span>;</span><br><span class="line"><span class="comment">//判断一个数是否是2的幂次方</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x - x &amp; (x - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">&#125;<span class="comment">//得到右数第一个1和后面的0构成的数</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;x;i++) x = x &amp; (x - <span class="number">1</span>);</span><br><span class="line"><span class="comment">//计算一个数的2进制有几个1</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Basic</tag>
      </tags>
  </entry>
  <entry>
    <title>CET6——Words &amp;&amp; Sentence&#39;s Accumulation</title>
    <url>/2023/05/03/cet6%E2%80%94%E2%80%94words-sentence-s-accumulation/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>This article is used for Mathic’s memory of important words and sentence patterns before preparing for the CET6 examination.&gt; _ &lt;</p>
<span id="more"></span>]]></content>
      <categories>
        <category>CET6</category>
      </categories>
      <tags>
        <tag>Words</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces_1.6k</title>
    <url>/2018/12/03/codeforces-1-2klower/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><center>随手练练 Codeforces 上面的题目，这大概是 1600 分的题目随手记</center>

<span id="more"></span>
]]></content>
      <tags>
        <tag>codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>从 FFT 到 NTT</title>
    <url>/2023/07/09/fft-to-ntt/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><center>FFT 可以用来计算多项式乘法，但复数的运算会产生浮点误差。对于只有整数参与的多项式运算，有时，使用数论变换（Number-Theoretic Transform）会是更好的选择。</center>

<span id="more"></span>
<h3 id="原根"><a href="#原根" class="headerlink" title="原根"></a>原根</h3><p>FFT 中，我们使用单位复根$\omega_n ^ k = \cos \frac{2 \pi}{n}k + i \sin\frac{2 \pi}{n}k$。我们需要单位复根的以下性质。</p>
<ol>
<li>$\omega_n ^ t (0 \leq t \leq n - 1)$互不相同，保证点值表示的合法；</li>
<li>$\omega_{2n} ^ {2k} = \omega_n ^ k$，用于分治；</li>
<li>$\omega_n ^ { k + \frac{n}{2} } = -\omega_n ^ k$，用于分治；</li>
<li>当$k \neq 0$时，$1 + \omega_n ^ k + (\omega_n ^ k) ^ 2 + \dots + (\omega_n ^ k) ^ {n - 1} = 0$，用于逆变换。</li>
</ol>
<p>在数论中，考虑一个质数$p = qn + 1$（其中$n$为$2$的幂）。定义其<strong>原根</strong>$g$为使得$g ^ i(0 \leq i \leq p - 1)$互不相同的数。</p>
<h4 id="性质一"><a href="#性质一" class="headerlink" title="性质一"></a>性质一</h4><p>令$\omega_n = g ^ q$，由于$1,\ g ^ q,\ g ^ {2q},\ \dots,\ g ^ {(n - 1)q}$互不相同，满足<strong>性质一</strong>。</p>
<h4 id="性质二"><a href="#性质二" class="headerlink" title="性质二"></a>性质二</h4><p>由$\omega<em>n = g ^ q$可知$\omega</em>{2n} = g ^ { \frac{q}{2} }$（$p = \frac{q}{2} \times 2n + 1$），故$\omega_{2n} ^ {2k} = g ^ {2k \frac{q}{2} } = g ^ {kq} = \omega_n ^ k$，满足<strong>性质二</strong>。</p>
<h4 id="性质三"><a href="#性质三" class="headerlink" title="性质三"></a>性质三</h4><p>根据费马小定理得</p>
<script type="math/tex; mode=display">\omega_n ^ n = g ^ {nq} = g ^ {p - 1} \equiv 1 \pmod p</script><p>又因为$(\omega_{n} ^ { \frac{n}{2} }) ^ 2 = \omega_n ^ n$，所以$\omega_n ^ { \frac{n}{2} } \equiv \pm 1 \pmod p$，</p>
<p>而根据性质一可得$\omega_n ^ { \frac{n}{2} } \neq \omega_n ^ 0$，即$\omega_n ^ {\frac{n}{2}} \equiv -1 \pmod p$。可推出$\omega_n ^ { k + \frac{n}{2} } = \omega_n ^ k \times \omega_n ^ { \frac{n}{2} } \equiv -\omega_n ^ k \pmod p$​，满足<strong>性质三</strong>。</p>
<h4 id="性质四"><a href="#性质四" class="headerlink" title="性质四"></a>性质四</h4><p>当$k \neq 0$时</p>
<script type="math/tex; mode=display">\begin{aligned} S(\omega_n ^ k) &= 1 + \omega_n ^ k + (\omega_n ^ k) ^ 2 + \dots + (\omega_n ^ k) ^ {n - 1} \\ \omega_n ^ k S(\omega_n ^ k) &= \omega_n ^ k + (\omega_n ^ k) ^ 2 + (\omega_n ^ k) ^ 3 + \dots + (\omega_n ^ k) ^ n \\ \omega_n ^ k S(\omega_n ^ k) - S(\omega_n ^ k) &= (\omega_n ^ k) ^ n - 1 \\ S(\omega_n ^ k) &= \frac{(\omega_n ^ k) ^ n - 1}{\omega_n ^ k - 1} \end{aligned}</script><p>由<strong>性质三</strong>中的推论可知，$(\omega_n ^ k) ^ n - 1 \equiv 0 \pmod p$，故$S(\omega_n ^ k) \equiv 0 \pmod p$，<strong>性质四</strong>成立。</p>
<h3 id="求原根"><a href="#求原根" class="headerlink" title="求原根"></a>求原根</h3><p>求一个质数的原根，可以使用枚举法 —— 枚举$g$，检验$g$是否为$p$的原根。</p>
<blockquote>
<p>对于一个数$g$，最小的满足$g ^ k \equiv 1 \pmod p$的正整数$k$一定是$p - 1$的约数。</p>
</blockquote>
<p>证明：假设最小的$k$不是$p - 1$的约数，找到$x$满足$xk &gt; p - 1 &gt; (x - 1)k$，由费马小定理可知</p>
<script type="math/tex; mode=display">g ^ {xk} \equiv g ^ {p - 1} \equiv 1 \equiv g ^ {xk - (p - 1)} \pmod p</script><p>$xk - (p - 1) &lt; k $，与假设矛盾。</p>
<p>检验时，只需要枚举$p - 1$的所有约数$q$，检验$g ^ q \not\equiv 1 \pmod p$即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">long</span> <span class="type">long</span> <span class="title">pow</span><span class="params">(<span class="type">const</span> <span class="type">long</span> <span class="type">long</span> x, <span class="type">const</span> <span class="type">long</span> <span class="type">long</span> n, <span class="type">const</span> <span class="type">long</span> <span class="type">long</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> <span class="type">long</span> num = x, tmp = n; tmp; tmp &gt;&gt;= <span class="number">1</span>, num = num * num % p) <span class="keyword">if</span> (tmp &amp; <span class="number">1</span>) ans = ans * num % p;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">long</span> <span class="type">long</span> <span class="title">root</span><span class="params">(<span class="type">const</span> <span class="type">long</span> <span class="type">long</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= p; i++) &#123;</span><br><span class="line">        <span class="type">int</span> x = p - <span class="number">1</span>;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">2</span>; k * k &lt;= p - <span class="number">1</span>; k++) <span class="keyword">if</span> (x % k == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">pow</span>(i, (p - <span class="number">1</span>) / k, p) == <span class="number">1</span>) &#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (x % k == <span class="number">0</span>) x /= k;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!flag &amp;&amp; (x == <span class="number">1</span> || <span class="built_in">pow</span>(i, (p - <span class="number">1</span>) / x, p) != <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><p>把原有的复数运算改为模意义下的运算即可。</p>
<p>注意$\div n$要改为$\times n ^ {-1}$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">long</span> <span class="type">long</span> <span class="title">pow</span><span class="params">(<span class="type">const</span> <span class="type">long</span> <span class="type">long</span> x, <span class="type">const</span> <span class="type">long</span> <span class="type">long</span> n, <span class="type">const</span> <span class="type">long</span> <span class="type">long</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> <span class="type">long</span> num = x, tmp = n; tmp; tmp &gt;&gt;= <span class="number">1</span>, num = num * num % p) <span class="keyword">if</span> (tmp &amp; <span class="number">1</span>) ans = ans * num % p;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">long</span> <span class="type">long</span> <span class="title">root</span><span class="params">(<span class="type">const</span> <span class="type">long</span> <span class="type">long</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= p; i++) &#123;</span><br><span class="line">        <span class="type">int</span> x = p - <span class="number">1</span>;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">2</span>; k * k &lt;= p - <span class="number">1</span>; k++) <span class="keyword">if</span> (x % k == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">pow</span>(i, (p - <span class="number">1</span>) / k, p) == <span class="number">1</span>) &#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (x % k == <span class="number">0</span>) x /= k;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!flag &amp;&amp; (x == <span class="number">1</span> || <span class="built_in">pow</span>(i, (p - <span class="number">1</span>) / x, p) != <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">exgcd</span><span class="params">(<span class="type">const</span> <span class="type">long</span> <span class="type">long</span> a, <span class="type">const</span> <span class="type">long</span> <span class="type">long</span> b, <span class="type">long</span> <span class="type">long</span> &amp;g, <span class="type">long</span> <span class="type">long</span> &amp;x, <span class="type">long</span> <span class="type">long</span> &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b) g = a, x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">exgcd</span>(b, a % b, g, y, x), y -= x * (a / b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">long</span> <span class="type">long</span> <span class="title">inv</span><span class="params">(<span class="type">const</span> <span class="type">long</span> <span class="type">long</span> a, <span class="type">const</span> <span class="type">long</span> <span class="type">long</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> g, x, y;</span><br><span class="line">    <span class="built_in">exgcd</span>(a, p, g, x, y);</span><br><span class="line">    <span class="keyword">return</span> (x + p) % p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">NumberTheoreticTransform</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> omega[MAXM_EXTENDED], omegaInverse[MAXM_EXTENDED];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">const</span> <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> g = <span class="built_in">root</span>(MOD), x = <span class="built_in">pow</span>(g, (MOD - <span class="number">1</span>) / n, MOD);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">assert</span>(i &lt; MAXM_EXTENDED);</span><br><span class="line">            omega[i] = (i == <span class="number">0</span>) ? <span class="number">1</span> : omega[i - <span class="number">1</span>] * x % MOD;</span><br><span class="line">            omegaInverse[i] = <span class="built_in">inv</span>(omega[i], MOD);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">transform</span><span class="params">(<span class="type">long</span> <span class="type">long</span> *a, <span class="type">const</span> <span class="type">int</span> n, <span class="type">const</span> <span class="type">long</span> <span class="type">long</span> *omega)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((<span class="number">1</span> &lt;&lt; k) != n) k++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; k; j++) <span class="keyword">if</span> (i &amp; (<span class="number">1</span> &lt;&lt; j)) t |= (<span class="number">1</span> &lt;&lt; (k - j - <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">if</span> (t &gt; i) std::<span class="built_in">swap</span>(a[i], a[t]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">2</span>; l &lt;= n; l *= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="type">int</span> m = l / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">long</span> <span class="type">long</span> *p = a; p != a + n; p += l) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">                    <span class="type">long</span> <span class="type">long</span> t = omega[n / l * i] * p[i + m] % MOD;</span><br><span class="line">                    p[i + m] = (p[i] - t + MOD) % MOD;</span><br><span class="line">                    (p[i] += t) %= MOD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dft</span><span class="params">(<span class="type">long</span> <span class="type">long</span> *a, <span class="type">const</span> <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">transform</span>(a, n, omega);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">idft</span><span class="params">(<span class="type">long</span> <span class="type">long</span> *a, <span class="type">const</span> <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">transform</span>(a, n, omegaInverse);</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> x = <span class="built_in">inv</span>(n, MOD);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) a[i] = a[i] * x % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; ntt;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>原根</tag>
        <tag>多项式</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串算法--KMP，字典树</title>
    <url>/2023/04/24/kmp-trie-tree/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>KMP特点：1.  i  不回退  2.  j  回退的位置有讲究  3.构建一个辅助数组（ nxt 数组）来跳过不必要的字符比较，从而提高搜索速度。</p>
<span id="more"></span>
<h1 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h1><blockquote>
<p>实际上，完全没必要从 S​ 的每一个字符开始，暴力穷举每一种情况，Knuth、Morris和 Pratt 对该算法进行了改进，称为 ​ KMP  算法。</p>
</blockquote>
<p>而 KMP 的精髓在于，对于每次失配之后，我都不会从头重新开始枚举，而是根据我已经得知的数据，从某个特定的位置开始匹配；而对于模式串的每一位，都有唯一的“特定变化位置”，这个在失配之后的特定变化位置可以帮助我们利用已有的数据不用从头匹配，从而节约时间。</p>
<p><strong>特点：1.   i  不回退  2.   j  回退的位置有讲究  3.构建一个辅助数组（ nxt 数组）来跳过不必要的字符比较，从而提高搜索速度。</strong></p>
<h2 id="实现流程"><a href="#实现流程" class="headerlink" title="实现流程"></a>实现流程</h2><p><img src="https://img2023.cnblogs.com/blog/1452231/202303/1452231-20230327195717908-1728308013.png" alt="image"></p>
<p><img src="https://img2023.cnblogs.com/blog/1452231/202303/1452231-20230327195854428-439903413.png" alt=""></p>
<p>为了清楚地表述目的，  T  与  S  失配前的部分作为  T’  来表述，此时寻找下一个开始匹配的标志头。而找到下一个标志头的方式为：</p>
<blockquote>
<p>找到   T’  的最长相同前缀与后缀</p>
</blockquote>
<p><img src="https://img2023.cnblogs.com/blog/1452231/202303/1452231-20230327200218970-204893744.png" alt="image"></p>
<p><img src="https://img2022.cnblogs.com/blog/1452231/202207/1452231-20220725200649652-71907780.png" alt="image"></p>
 <font color=red>这样找所有的前缀和后缀比较，是不是也是暴力穷举？那该怎么办呢？<br></br>ans:当然是要用到动态规划递推啦。</font>

<h3 id="构建-Nxt-数组"><a href="#构建-Nxt-数组" class="headerlink" title="构建 Nxt 数组"></a>构建 Nxt 数组</h3><p> $nxt$  数组用于表示当前字符匹配失败时，模式串应该回退到哪个位置。对于模式串 $p$ ，我们遍历其每个字符，并用一个指针  $j$  表示已匹配的字符数。当模式串中的两个字符匹配时，我们更新指针 $j$ 的值，否则，我们回退  $j$  到  $nxt[j]$  的位置。通过这种方式，我们可以为模式串构建一个  $nxt$  数组，其中  $nxt[i]$  表示当模式串中第  $i$  个字符匹配失败时，应该回退到的位置。</p>
<h3 id="实际字符匹配过程"><a href="#实际字符匹配过程" class="headerlink" title="实际字符匹配过程"></a>实际字符匹配过程</h3><p>我们使用两个指针  i  和  j  分别遍历原字符串  s  和模式串  p  。如果当前字符匹配，则同时移动  i  和  j  。如果字符不匹配，我们根据  nxt  数组回退  j  的位置，直到找到匹配的字符或回退到模式串的开头。当  j  等于模式串长度  m  时，表示找到了一个匹配，输出匹配位置，并将  j  重置为  0  。</p>
<h2 id="模板代码实现"><a href="#模板代码实现" class="headerlink" title="模板代码实现"></a>模板代码实现</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e+6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> nxt[N], n, m;</span><br><span class="line"><span class="type">char</span> p[N], s[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; s + <span class="number">1</span> &gt;&gt; m &gt;&gt; p + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// build next arraylist</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &amp;&amp; p[i] != p[j + <span class="number">1</span>]) j = nxt[j];</span><br><span class="line">        <span class="keyword">if</span> (p[i] == p[j + <span class="number">1</span>]) j++;</span><br><span class="line">        nxt[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// marry the str</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i  = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &amp;&amp; s[i] != p[j + <span class="number">1</span>]) j = nxt[j];</span><br><span class="line">        <span class="keyword">if</span> (s[i] == p[j + <span class="number">1</span>]) j++;</span><br><span class="line">        <span class="keyword">if</span> (j == m) &#123;</span><br><span class="line">            cout &lt;&lt; i - m &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            j = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="字典树-又名Trie树、前缀树"><a href="#字典树-又名Trie树、前缀树" class="headerlink" title="字典树(又名Trie树、前缀树)"></a>字典树(又名Trie树、前缀树)</h1><p>字典树是一种高效的字符串数据结构，尤其适用于处理大量字符串的时候，它通过将<strong>字符串的公共前缀合并在一起</strong>，节省空间并提高查询速度。</p>
<h2 id="实现流程-1"><a href="#实现流程-1" class="headerlink" title="实现流程"></a>实现流程</h2><h3 id="初始化变量和数据结构"><a href="#初始化变量和数据结构" class="headerlink" title="初始化变量和数据结构"></a>初始化变量和数据结构</h3><p>定义一个字典树结构（ tree 数组）和一个记录字符串出现次数的数组（ vis 数组）。同时定义一个计数器  flag  用于记录字典树中节点的数量。二维数组  tree  表示字典树的结构，其中  <code>tree[i][j]</code>  表示第  <code>i</code> 个节点的第  <code>j</code>  个子节点。</p>
<h3 id="子功能实现"><a href="#子功能实现" class="headerlink" title="子功能实现"></a>子功能实现</h3><h4 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h4><p>实现一个  insert  函数，用于向字典树中插入一个字符串。它遍历字符串中的每个字符，将字符转换为数组下标（通过减去’  a  ‘并加上  1  ）。如果当前字符对应的子节点不存在，则创建一个新的节点并更新节点计数器。最后，在字符串末尾的节点中，更新字符串出现的次数。</p>
<h4 id="query"><a href="#query" class="headerlink" title="query"></a>query</h4><p>实现一个  query  函数，用于查询字典树中字符串的出现次数。它遍历字符串中的每个字符，将字符转换为数组下标。如果当前字符对应的子节点不存在，说明字符串不存在，查询结束。否则，将指针移动到子节点。最后，返回字符串末尾节点对应的出现次数。</p>
<h3 id="主程序逻辑"><a href="#主程序逻辑" class="headerlink" title="主程序逻辑"></a>主程序逻辑</h3><p>读取操作数量  n  ，然后循环处理每个操作。对于每个操作，读取操作类型（  ope  ）和操作字符串（  str  ）。如果操作类型为 “ i “ ，调用  insert  函数插入字符串；如果操作类型为其他（例如查询操作），调用  query  函数查询字符串，并输出查询结果。</p>
<h2 id="模板代码实现-1"><a href="#模板代码实现-1" class="headerlink" title="模板代码实现"></a>模板代码实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e+6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, flag = <span class="number">1</span>;</span><br><span class="line">string ope, str;</span><br><span class="line"><span class="type">int</span> tree[N][<span class="number">27</span>], vis[N][<span class="number">27</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = str[i] - <span class="string">&#x27;a&#x27;</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (tree[pos][tmp] == <span class="number">0</span>) tree[pos][tmp] = flag ++;</span><br><span class="line">        pos = tree[pos][tmp];</span><br><span class="line">    &#125;</span><br><span class="line">    vis[pos][tmp] ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(string str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i  = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = str[i] - <span class="string">&#x27;a&#x27;</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (tree[pos][tmp] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        pos = tree[pos][tmp];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vis[pos][tmp];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span> (n--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; ope &gt;&gt; str;</span><br><span class="line">        <span class="keyword">if</span> (ope == <span class="string">&quot;i&quot;</span>) <span class="built_in">insert</span>(str);</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="built_in">query</span>(str) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法学习笔记</category>
      </categories>
      <tags>
        <tag>KMP</tag>
        <tag>字典树</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷日报 2018-至今の索引</title>
    <url>/2023/06/16/luogu-reports/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><center>luogu 日报还是能学到不少东西捏</center>

<span id="more"></span>
<h3 id="7-月"><a href="#7-月" class="headerlink" title="7 月"></a>7 月</h3><h4 id="17-树链剖分详解（作者：communist）"><a href="#17-树链剖分详解（作者：communist）" class="headerlink" title="#17　树链剖分详解（作者：communist）"></a>#17　树链剖分详解（作者：communist）</h4><p><a href="https://www.luogu.org/blog/communist/shu-lian-pou-fen-yang-xie">https://www.luogu.org/blog/communist/shu-lian-pou-fen-yang-xie</a></p>
<h4 id="16-SPFA算法教学（作者：Ryanwxn）"><a href="#16-SPFA算法教学（作者：Ryanwxn）" class="headerlink" title="#16　SPFA算法教学（作者：Ryanwxn）"></a>#16　SPFA算法教学（作者：Ryanwxn）</h4><p><a href="https://www.luogu.org/blog/83547/spfa-suan-fa-jiao-xue">https://www.luogu.org/blog/83547/spfa-suan-fa-jiao-xue</a>    </p>
<h4 id="15-小谈基数排序（作者：Creeper-LKF）"><a href="#15-小谈基数排序（作者：Creeper-LKF）" class="headerlink" title="#15　小谈基数排序（作者：Creeper_LKF）"></a>#15　小谈基数排序（作者：Creeper_LKF）</h4><p><a href="https://www.luogu.org/blog/CreeperLKF/Radix-Sort">https://www.luogu.org/blog/CreeperLKF/Radix-Sort</a></p>
<h4 id="14-用最通俗的语言让你学会网络流（作者：钱逸凡）"><a href="#14-用最通俗的语言让你学会网络流（作者：钱逸凡）" class="headerlink" title="#14　用最通俗的语言让你学会网络流（作者：钱逸凡）"></a>#14　用最通俗的语言让你学会网络流（作者：钱逸凡）</h4><p><a href="https://www.luogu.org/blog/ONE-PIECE/wang-lao-liu-di-zong-jie">https://www.luogu.org/blog/ONE-PIECE/wang-lao-liu-di-zong-jie</a></p>
<h4 id="13-浅谈二分的边界问题（作者：曦行夜落）"><a href="#13-浅谈二分的边界问题（作者：曦行夜落）" class="headerlink" title="#13　浅谈二分的边界问题（作者：曦行夜落）"></a>#13　浅谈二分的边界问题（作者：曦行夜落）</h4><p><a href="https://www.luogu.com.cn/blog/_post/49841">https://www.luogu.com.cn/blog/_post/49841</a></p>
<h4 id="12-现代编辑器食用指北-VSCode（作者：FancyDreams）"><a href="#12-现代编辑器食用指北-VSCode（作者：FancyDreams）" class="headerlink" title="#12　现代编辑器食用指北-VSCode（作者：FancyDreams）"></a>#12　现代编辑器食用指北-VSCode（作者：FancyDreams）</h4><p><a href="https://www.luogu.org/blog/GNAQ/VSC-guide">https://www.luogu.org/blog/GNAQ/VSC-guide</a></p>
<h4 id="11-浅析基础数据结构-二叉堆（作者：henry-y）"><a href="#11-浅析基础数据结构-二叉堆（作者：henry-y）" class="headerlink" title="#11　浅析基础数据结构-二叉堆（作者：henry_y）"></a>#11　浅析基础数据结构-二叉堆（作者：henry_y）</h4><p><a href="https://www.luogu.org/blog/henry-y/qian-xi-ji-chu-shuo-ju-jie-gou-er-cha-dui">https://www.luogu.org/blog/henry-y/qian-xi-ji-chu-shuo-ju-jie-gou-er-cha-dui</a></p>
<h4 id="10-有趣又有用的信息学竞赛（作者：LuckyCloud）"><a href="#10-有趣又有用的信息学竞赛（作者：LuckyCloud）" class="headerlink" title="#10　有趣又有用的信息学竞赛（作者：LuckyCloud）"></a>#10　有趣又有用的信息学竞赛（作者：LuckyCloud）</h4><p><a href="https://luckycloud.blog.luogu.org/oi-xin-xi-xue-jing-sai-post">https://luckycloud.blog.luogu.org/oi-xin-xi-xue-jing-sai-post</a></p>
<h4 id="9-朝花中学OI队的奋斗历程——浅谈单调队列（作者：Sweetlemon）"><a href="#9-朝花中学OI队的奋斗历程——浅谈单调队列（作者：Sweetlemon）" class="headerlink" title="#9　朝花中学OI队的奋斗历程——浅谈单调队列（作者：Sweetlemon）"></a>#9　朝花中学OI队的奋斗历程——浅谈单调队列（作者：Sweetlemon）</h4><p><a href="https://sweetlemon.blog.luogu.org/dan-diao-dui-lie">https://sweetlemon.blog.luogu.org/dan-diao-dui-lie</a></p>
<h4 id="8-由于内容有较多争议，决定撤下"><a href="#8-由于内容有较多争议，决定撤下" class="headerlink" title="#8 由于内容有较多争议，决定撤下"></a>#8 由于内容有较多争议，决定撤下</h4><h4 id="7-STL整理之set（作者：communist）"><a href="#7-STL整理之set（作者：communist）" class="headerlink" title="#7　STL整理之set（作者：communist）"></a>#7　STL整理之set（作者：communist）</h4><p><a href="https://www.luogu.org/blog/communist/stl-zheng-li-zhi-set">https://www.luogu.org/blog/communist/stl-zheng-li-zhi-set</a></p>
<h4 id="6-练习Linux？其实你的Win10自带一个Ubuntu（作者：asfr）"><a href="#6-练习Linux？其实你的Win10自带一个Ubuntu（作者：asfr）" class="headerlink" title="#6　练习Linux？其实你的Win10自带一个Ubuntu（作者：asfr）"></a>#6　练习Linux？其实你的Win10自带一个Ubuntu（作者：asfr）</h4><p><a href="https://www.luogu.org/blog/asfr/Run-Ubuntu-On-Windows10">https://www.luogu.org/blog/asfr/Run-Ubuntu-On-Windows10</a></p>
<h4 id="5-信息学竞赛全攻略（一）：竞赛基本概况（报名与赛程）（作者：kkksc03）"><a href="#5-信息学竞赛全攻略（一）：竞赛基本概况（报名与赛程）（作者：kkksc03）" class="headerlink" title="#5　信息学竞赛全攻略（一）：竞赛基本概况（报名与赛程）（作者：kkksc03）"></a>#5　信息学竞赛全攻略（一）：竞赛基本概况（报名与赛程）（作者：kkksc03）</h4><p><a href="https://www.luogu.com.cn/blog/kkksc03/oi-descption1">https://www.luogu.com.cn/blog/kkksc03/oi-descption1</a></p>
<h4 id="4-浅谈线段树（Segment-Tree）（作者：皎月半洒花）"><a href="#4-浅谈线段树（Segment-Tree）（作者：皎月半洒花）" class="headerlink" title="#4　浅谈线段树（Segment Tree）（作者：皎月半洒花）"></a>#4　浅谈线段树（Segment Tree）（作者：皎月半洒花）</h4><p><a href="https://pks-loving.blog.luogu.org/senior-data-structure-qian-tan-xian-duan-shu-segment-tree">https://pks-loving.blog.luogu.org/senior-data-structure-qian-tan-xian-duan-shu-segment-tree</a></p>
<h4 id="3-5G，咫尺未来！（作者：宁一）"><a href="#3-5G，咫尺未来！（作者：宁一）" class="headerlink" title="#3　5G，咫尺未来！（作者：宁一）"></a>#3　5G，咫尺未来！（作者：宁一）</h4><p><a href="https://ning-yi.blog.luogu.org/post-5g-zhi-chi-wei-lai-post">https://ning-yi.blog.luogu.org/post-5g-zhi-chi-wei-lai-post</a></p>
<h4 id="2-关于二叉查找树的一些事儿（bst详解，平衡树入门）（作者：ztz11）"><a href="#2-关于二叉查找树的一些事儿（bst详解，平衡树入门）（作者：ztz11）" class="headerlink" title="#2　关于二叉查找树的一些事儿（bst详解，平衡树入门）（作者：ztz11）"></a>#2　关于二叉查找树的一些事儿（bst详解，平衡树入门）（作者：ztz11）</h4><p><a href="https://www.luogu.org/blog/ztz11/pinghengshu-bst">https://www.luogu.org/blog/ztz11/pinghengshu-bst</a></p>
<h4 id="1-洛谷日报征稿中（作者：kkksc03）"><a href="#1-洛谷日报征稿中（作者：kkksc03）" class="headerlink" title="#1　洛谷日报征稿中（作者：kkksc03）"></a>#1　洛谷日报征稿中（作者：kkksc03）</h4><p><a href="https://www.luogu.org/blog/kkksc03/call-for-article">https://www.luogu.org/blog/kkksc03/call-for-article</a></p>
]]></content>
      <tags>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title>Mathic の 代码风格</title>
    <url>/2023/05/06/mathic%E3%81%AE%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><center>MathicTeaxion 选手在 OI 和 ACM 竞赛中总结的代码规范，欢迎来踩！</center>

<span id="more"></span>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><code>#include​</code> 语句必须置于整个程序的开头。</p>
<p>不应 <code>using namespace foo;</code> 若有必要可以 <code>using foo::bar;</code></p>
<p>单行字符数必须不超过$80$。</p>
<h2 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h2><p><code>#include​</code> 的多个库顺序可有以下两种：</p>
<p>C++ 标准库在前，之后是 C​ 标准库，再后为其它（如交互库等）（工程代码中，本 $cpp$ 所对应的 $.h$ 文件应置于开头。）<br>（仅适用于 $Oi$ ）按字典序依次排列。</p>
<p>如果有多层嵌套<code>#if</code> , <code>#endif</code> , <code>#endif​</code>后应有对应的注释标识出与其对应的​<code>#if​</code>。</p>
<p>尽量不要适用<code>#define​</code>而使用 <code>const</code> ,  <code>typedef</code> , <code>inline</code>。</p>
<p>所有预编译命令不应缩进（见下）。</p>
<h2 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h2><p>每个代码块采用  $2$  空格缩进。</p>
<h2 id="空格及换行"><a href="#空格及换行" class="headerlink" title="空格及换行"></a>空格及换行</h2><p>大括号不换行。</p>
<h3 id="需要加空格的地方："><a href="#需要加空格的地方：" class="headerlink" title="需要加空格的地方："></a>需要加空格的地方：</h3><ul>
<li>二元运算符（包括赋值运算符）两侧（运算符例外，见下）；</li>
<li><code>.,</code> 及 <code>;</code> 的右边（如果其不处于行尾）；</li>
<li><code>if</code>, <code>for</code>等控制流关键字与其后的左括号之间 ；</li>
<li><code>do-while</code>中的<code>while</code>、<code>if-else</code>中的<code>else</code>与其前面的右大括号之间；</li>
<li>所有左大括号的左侧（根据不换行的策略，左大括号不应处于行首）；</li>
<li><code>? :</code>的两侧（包括构造函数初始化列表中的<code>:</code>）；<br>类型中<code>*</code>,<code>&amp;</code>的左侧（如：<code>const int &amp;a</code>, <code>int A(int *&amp;a)</code>）；<br>花括号与其内部语句/数组初始化列表之间（如果在同一行）；<br>常成员函数的<code>const</code>两侧。</li>
</ul>
<h3 id="一定不能加空格的地方："><a href="#一定不能加空格的地方：" class="headerlink" title="一定不能加空格的地方："></a>一定不能加空格的地方：</h3><p>小括号及中括号与其内部的表达式/参数列表之间；<br>函数名与左括号之间（包括声明/定义/使用）；<br>单目运算符（ <code>!</code> , <code>-</code> , <code>*</code> , <code>&amp;</code> , <code>~</code> ）之后（或自增自减运算符与其操作数之间）；<br> <code>,</code> 及 <code>;</code> 的左侧；<br>类型中*,&amp;的右侧；<br> <code>.</code> , <code>-&gt;</code> , <code>::</code> 的两侧；<br><code>operator</code> 与所要重载的运算符之间（运算符与参数列表之间，根据第 $2$ 条，也不应空格）。<br>若表达式过长内部可以换行，运算符处于行首（而非行尾）；缩进以使表达式对齐为准；换行的优先级较高的子表达式也应加括号以避免误读。</p>
<p>参数列表/初始化列表过长时内部也可换行，逗号处于行尾；缩四空格。</p>
<p>极短的函数可以写到一行（但绝不能超过 $80$ 字符）。</p>
<p>例子：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct AVeryVeryVeryVeryVeryVeryVeryVeryVeryLongStruct&#123;</span><br><span class="line">  int aVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongVariable, d;</span><br><span class="line">  AVeryVeryVeryVeryVeryVeryVeryVeryVeryLongStruct(int a, int b, int c, int d)</span><br><span class="line">      : aVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongVariable(a) &#123;</span><br><span class="line">    this-&gt;d = b + c * d;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">inline int min(int x, int y) &#123; return x &lt; y ? x : y; &#125;</span><br><span class="line">int gcd(int x, int y) &#123; return y ? gcd(y, x % y) : x; &#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">  int thisVariableIsToBeLong = 2, thisVariableIsToBeLongerAndLonger = 23;</span><br><span class="line">  AVeryVeryVeryVeryVeryVeryVeryVeryVeryLongStruct s(</span><br><span class="line">      thisVariableIsToBeLong, thisVariableIsToBeLong,</span><br><span class="line">      thisVariableIsToBeLongerAndLonger,</span><br><span class="line">      thisVariableIsToBeLongerAndLonger</span><br><span class="line">  );</span><br><span class="line">  printf(&quot;%d\n&quot;, s.d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="空行"><a href="#空行" class="headerlink" title="空行"></a>空行</h2><p>所有 <code>#include &lt;foobar&gt;</code> 与 <code>using foo::bar;</code> 之间不应空行，之后应空一行。</p>
<p>一系列常量定义的上下应有空行。</p>
<p>函数/结构体定义两侧应有空行（一系列短小到可以写到一行的函数，如<code>min</code> , <code>max</code> ，之间可以不空行）。</p>
<p>一系列全局变量定义的上下应有空行。</p>
<p>语句之间可根据其意义酌情空行。</p>
<p>任何位置不能出现连续的两个（或以上）空行。</p>
<p>函数定义<br><code>main​</code>函数返回值必须为​<code>int</code> ​, <code>return 0​</code>不可忽略；</p>
<p>类/结构体传参在大多数情况下不应传值（除非难以避免地产生拷贝，或一些特殊要求），而应传引用。</p>
<p>极其简短的函数可以写作一行（但绝不能超过 $80$ 字符），此时花括号内部应有空格（空函数体 <code>&#123;&#125;</code> 除外）。</p>
<p>单个函数的长度不应过长（例如超过 $100$ 行）。</p>
<p>命名规则<br>一般情况下应采用驼峰命名法，变量开头小写，函数/类/结构体开头大写。</p>
<p>结构体/类成员函数，可以小写开头。</p>
<p>特例：</p>
<p><code>main</code>函数；<br>变量可以以一个小写字母命名；<br>全局数组名可使用 1 个大写字母 + 0~2 个数字命名，如A, T1,F01；<br>模板。如 <code>readInt</code> ,  <code>pow_mod</code> ;<br>采用对应算法缩写，如 <code>KMP</code> ,  <code>CRT</code> ,  <code>NTT</code>  , <code>CDQ</code> ；<br>简短的 <code>inline</code> 函数，如 <code>min</code> ,  <code>upd</code> (用作数据结构中的 update 操作);<br>常量可以大写字母命名，如 <code>N</code> ,  <code>M</code> ；<br>临时变量可以以下划线开头。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Example Code</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">readInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">0</span>, c;</span><br><span class="line">  <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c = <span class="built_in">getchar</span>()));</span><br><span class="line">  <span class="keyword">do</span> ans = ans * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c = <span class="built_in">getchar</span>()));</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> g = <span class="number">3</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200050</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">pow_mod</span><span class="params">(LL x, <span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">  LL ans = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> ((p += mod - <span class="number">1</span>) %= (mod - <span class="number">1</span>); p; p &gt;&gt;= <span class="number">1</span>, (x *= x) %= mod)</span><br><span class="line">    <span class="keyword">if</span> (p &amp; <span class="number">1</span>) (ans *= x) %= mod;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL inv[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">NTT</span><span class="params">(LL *A, <span class="type">int</span> len, <span class="type">int</span> opt)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">    <span class="type">int</span> k = len;</span><br><span class="line">    <span class="keyword">while</span> (~j &amp; k) j ^= (k &gt;&gt;= <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (i &lt; j) std::<span class="built_in">swap</span>(A[i], A[j]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> h = <span class="number">2</span>; h &lt;= len; h &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    LL wn = <span class="built_in">pow_mod</span>(g, (mod - <span class="number">1</span>) / h * opt);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; len; j += h) &#123;</span><br><span class="line">      LL w = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = j; i &lt; j + (h &gt;&gt; <span class="number">1</span>); ++i) &#123;</span><br><span class="line">        LL _tmp1 = A[i], _tmp2 = A[i + (h &gt;&gt; <span class="number">1</span>)] * w;</span><br><span class="line">        A[i] = (_tmp1 + _tmp2) % mod;</span><br><span class="line">        A[i + (h &gt;&gt; <span class="number">1</span>)] = (_tmp1 - _tmp2) % mod;</span><br><span class="line">        (w *= wn) %= mod;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (opt == <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">      (A[i] *= -(mod - <span class="number">1</span>) / len) %= mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL F[N], G[N];</span><br><span class="line">LL T1[N * <span class="number">4</span>], T2[N * <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Conv</span><span class="params">(LL *A, <span class="type">int</span> n, LL *B, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> len = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (len &lt;= n + m) len &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">    T1[i] = (i &lt; n ? A[i] : <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">    T2[i] = (i &lt; m ? B[i] : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">NTT</span>(T1, len, <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">NTT</span>(T2, len, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">    (T1[i] *= T2[i]) %= mod;</span><br><span class="line">  <span class="built_in">NTT</span>(T1, len, <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Solve</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l == r - <span class="number">1</span>) &#123;</span><br><span class="line">    F[l] = (l == <span class="number">0</span> ? <span class="number">1</span> : F[l] * inv[l] % mod);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">Solve</span>(l, mid);</span><br><span class="line">  <span class="built_in">Conv</span>(F + l, mid - l, G, r - l);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = mid; i &lt; r; ++i)</span><br><span class="line">    (F[i] += T1[i - l]) %= mod;</span><br><span class="line">  <span class="built_in">Solve</span>(mid, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  n = <span class="built_in">readInt</span>();</span><br><span class="line"></span><br><span class="line">  inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">    inv[i] = -(mod / i) * inv[mod % i] % mod;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;G[i]);</span><br><span class="line">    (G[i] *= i) %= mod;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Solve</span>(<span class="number">0</span>, n + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, (F[i] + mod) % mod);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注：此为多项式 exp​ 模板。</p>
]]></content>
      <categories>
        <category>代码规范</category>
      </categories>
      <tags>
        <tag>代码风格</tag>
      </tags>
  </entry>
  <entry>
    <title>XCPC-Holiday-Plan</title>
    <url>/2023/06/30/xcpc-holiday-pracplan/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><center>在暑假励志刷爆全部 Div3 + Div4 喵！</center>

<span id="more"></span>
<h2 id="Round-826-Div-3"><a href="#Round-826-Div-3" class="headerlink" title="Round 826 (Div. 3)"></a>Round 826 (Div. 3)</h2><h3 id="F-Multi-Colored-Segments"><a href="#F-Multi-Colored-Segments" class="headerlink" title="F. Multi-Colored Segments"></a><a href="https://codeforces.com/contest/1741/problem/F">F. Multi-Colored Segments</a></h3><blockquote>
<p>找左边的就是找满足  $l_j &lt;= l_i$ 的最大的 $r_j$，由于要颜色不同，所以存最大的两个，倒过来再跑一遍求右边的。——$jiangly$</p>
</blockquote>
<p>对每条线段的两个端点进行排序，对于每个点，判断其是否是线段的开始点或结束点，然后根据其是否是开始点或结束点进行不同的操作。</p>
<p>每个五元组在数组中代表一个端点及其相关信息，如果一个点是开始点，则比较其结束坐标和当前记录的最远的线段结束坐标，并更新。如果一个点是结束点，那么就更新结果数组中对应的值。</p>
<p>当我们说 <code>pts[2 * i] = &#123;l, r, c, i, 0&#125;;</code> ，我们在存储一条线段的起点 <code>l</code> 信息，并且记住这个起点对应的线段的另一个端点（即终点）的位置 <code>r</code> ，线段的颜色 <code>c</code> ，线段的序号 <code>i</code> （表示这是第几个线段），以及标志位 <code>0</code> （表示这是一个起点）。</p>
<p>相似的， <code>pts[2 * i + 1] = &#123;r, l, c, i, 1&#125;;</code> 是在存储一条线段的终点 <code>r</code> 信息，并记住终点对应的起点 <code>l</code> ，线段的颜色 <code>c</code> ，线段的序号 <code>i</code> ，以及标志位 <code>1</code> （表示这是一个终点）。</p>
<p>加上两个判断条件：</p>
<p>（1）当前线段的右端点在f[0]所代表的线段的右端点的右侧时交换位置</p>
<p>（2）如果当前线段的右端点值<code>g[0]</code>大于f数组中存储的次大右端点值<code>f[1][0]</code>，并且当前线段的颜色<code>g[1]</code>与f数组中存储的最大右端点值对应的线段颜色<code>f[0][1]</code>不同，那么将<code>f[1]</code>更新为g</p>
<p>（3）为了维护<code>f</code>中的两个元素尽可能地不同色，且右端点值尽可能地大，如果<code>f</code>中最大和次大右端点值对应的线段颜色相同，将<code>f[1]</code>更新为<code>g</code>，使<code>f</code>中两元素尽可能不同色。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> INF = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;std::array&lt;<span class="type">int</span>, 5&gt;&gt; <span class="built_in">pts</span>(<span class="number">2</span> * n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l, r, c;</span><br><span class="line">        std::cin &gt;&gt; l &gt;&gt; r &gt;&gt; c;</span><br><span class="line">        pts[<span class="number">2</span> * i] = &#123;l, r, c, i, <span class="number">0</span>&#125;;</span><br><span class="line">        pts[<span class="number">2</span> * i + <span class="number">1</span>] = &#123;r, l, c, i, <span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">sort</span>(pts.<span class="built_in">begin</span>(), pts.<span class="built_in">end</span>());</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(n, INF)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> t = <span class="number">0</span>; t &lt; <span class="number">2</span>; t++)</span><br><span class="line">    &#123;</span><br><span class="line">        std::array&lt;<span class="type">int</span>, 2&gt; f[<span class="number">2</span>];</span><br><span class="line">        f[<span class="number">0</span>] = f[<span class="number">1</span>] = &#123;-INF, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [x, y, c, i, o] : pts)&#123;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="number">0</span>)&#123;</span><br><span class="line">                std::array g&#123;y, c&#125;;</span><br><span class="line">                <span class="keyword">if</span> (g &gt; f[<span class="number">0</span>])&#123;</span><br><span class="line">                    std::<span class="built_in">swap</span>(g, f[<span class="number">0</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>((g &gt; f[<span class="number">1</span>] &amp;&amp; g[<span class="number">1</span>] != f[<span class="number">0</span>][<span class="number">1</span>]) || f[<span class="number">0</span>][<span class="number">1</span>] == f[<span class="number">1</span>][<span class="number">1</span>])&#123; </span><br><span class="line">                    f[<span class="number">1</span>] = g;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> [z, d] : f)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(d != c)&#123;</span><br><span class="line">                        ans[i] = std::<span class="built_in">min</span>(ans[i], std::<span class="built_in">max</span>(<span class="number">0</span>, y - z));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        std::<span class="built_in">reverse</span>(pts.<span class="built_in">begin</span>(), pts.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;[x, y, c, i, o] : pts)&#123;</span><br><span class="line">            x = INF - x;</span><br><span class="line">            y = INF - y;</span><br><span class="line">            o ^= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">        std::cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&quot; \n&quot;</span>[i == n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    std::cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Round-827-Div-4-​"><a href="#Round-827-Div-4-​" class="headerlink" title="Round 827 (Div.4)​"></a>Round 827 (Div.4)​</h2><h3 id="D-Coprime"><a href="#D-Coprime" class="headerlink" title="D. Coprime"></a><a href="https://codeforces.com/contest/1742/problem/D">D. Coprime</a></h3><p>用一个 <code>last</code> 来记录每个数的最后出现的位置。即 <code>last[x] = i + 1</code> ，其中 <code>x</code> 是序列中的数字。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> INF = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">last</span><span class="params">(<span class="number">1001</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        std::cin &gt;&gt; x;</span><br><span class="line">        last[x] = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">1000</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (last[i] &amp;&amp; last[j] &amp;&amp; std::<span class="built_in">gcd</span>(i, j) == <span class="number">1</span>) &#123;</span><br><span class="line">                ans = std::<span class="built_in">max</span>(ans, last[i] + last[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    std::cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="E-Scuza"><a href="#E-Scuza" class="headerlink" title="E. Scuza"></a><a href="https://codeforces.com/contest/1742/problem/E">E. Scuza</a></h3><p><code>a[i] = std::max(a[i], a[i - 1])</code>确保每个楼梯的高度至少等于前一个楼梯的高度（也就是说，如果要到达更高的楼梯，步长必须更大）。</p>
<p>对于每个查询，使用二分查找<code>upper_bound</code>找到最高的可以到达的楼梯，然后使用前缀和<code>s[i]</code>找到可以到达的所有楼梯的总高度。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> INF = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, q;</span><br><span class="line">    std::cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">    <span class="function">std::vector&lt;i64&gt; <span class="title">a</span><span class="params">(n)</span>, <span class="title">s</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">        std::cin &gt;&gt; a[i];</span><br><span class="line">        s[i + <span class="number">1</span>] = s[i] + a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) a[i] = std::<span class="built_in">max</span>(a[i], a[i - <span class="number">1</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; q;i++)&#123;</span><br><span class="line">        <span class="type">int</span> k; std::cin &gt;&gt; k;</span><br><span class="line">        std::cout &lt;&lt; s[std::<span class="built_in">upper_bound</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), k) - a.<span class="built_in">begin</span>()] &lt;&lt; <span class="string">&quot; \n&quot;</span>[i == q - <span class="number">1</span>];</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> t; std::cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="F-Smaller"><a href="#F-Smaller" class="headerlink" title="F. Smaller"></a><a href="https://codeforces.com/contest/1742/problem/F">F. Smaller</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> INF = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> q;</span><br><span class="line">    std::cin &gt;&gt; q;</span><br><span class="line">    i64 lens = <span class="number">1</span>, lent = <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> mins = <span class="string">&#x27;a&#x27;</span>, maxs = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="type">char</span> mint = <span class="string">&#x27;a&#x27;</span>, maxt = <span class="string">&#x27;a&#x27;</span>; </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; q; i++) &#123;</span><br><span class="line">        <span class="type">int</span> o, k;</span><br><span class="line">        std::string s;</span><br><span class="line">        std::cin &gt;&gt; o &gt;&gt; k &gt;&gt; s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="number">1</span>) &#123;</span><br><span class="line">                mins = std::<span class="built_in">min</span>(mins, c);</span><br><span class="line">                maxs = std::<span class="built_in">max</span>(maxs, c);</span><br><span class="line">                lens += k;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mint = std::<span class="built_in">min</span>(mint, c);</span><br><span class="line">                maxt = std::<span class="built_in">max</span>(maxt, c);</span><br><span class="line">                lent += k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mins &lt; maxt || (mins == maxt &amp;&amp; mins == maxs &amp;&amp; mint == maxt &amp;&amp; lens &lt; lent)) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> T; std::cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="G-Orray"><a href="#G-Orray" class="headerlink" title="G. Orray"></a><a href="https://codeforces.com/contest/1742/problem/G">G. Orray</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> INF = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        std::cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; b;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">bool</span>&gt; <span class="title">vis</span><span class="params">(n)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> cur = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> mx = <span class="number">0</span>, k = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="type">int</span> x = a[j] &amp; ~cur;</span><br><span class="line">            <span class="keyword">if</span> (!vis[j] &amp;&amp; x &gt; mx) &#123;</span><br><span class="line">                mx = x;</span><br><span class="line">                k = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[k] = <span class="literal">true</span>;</span><br><span class="line">        b.<span class="built_in">push_back</span>(a[k]);</span><br><span class="line">        cur |= a[k];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i]) &#123;</span><br><span class="line">            b.<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        std::cout &lt;&lt; b[i] &lt;&lt; <span class="string">&quot; \n&quot;</span>[i == n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> T; std::cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Practise</category>
      </categories>
      <tags>
        <tag>扫描线算法</tag>
        <tag>区间更新</tag>
        <tag>二分搜索</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title>数论学习笔记</title>
    <url>/2023/04/24/%E6%95%B0%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><center>数论是 Crypto 中很重要的一部分，然而我基本不会，所以从现在开始我要成为数论糕手！</center>

<hr>
<span id="more"></span>
<h3 id="欧几里得"><a href="#欧几里得" class="headerlink" title="欧几里得"></a>欧几里得</h3><p>算是数论最基本的了吧，求两个数的最大公约数。</p>
<script type="math/tex; mode=display">\gcd(a,b)=\begin{cases}
a & b=0 \\
\gcd(b,a\ \rm{mod}\ b) & b\neq 0
\end{cases}</script><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !b ? a : <span class="built_in">gcd</span>(b, a % b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>顺便求两个数的最小公倍数。</p>
<script type="math/tex; mode=display">{\rm lcm}(a,b)=\frac{a*b}{\gcd(a,b)}</script><p>写程序时先除后乘防炸。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lcm</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a / <span class="built_in">gcd</span>(a, b) * b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="扩展欧几里得"><a href="#扩展欧几里得" class="headerlink" title="扩展欧几里得"></a>扩展欧几里得</h3><p>扩展欧几里得 <code>exgcd</code> 可以在求出 $\gcd(a,b)$ 的同时求出二元一次不定方程 $ax+by=\gcd(a,b)$的一组整数解。</p>
<p>举个栗子，求 $\gcd(47,30)$ 时，得到以下式子。</p>
<script type="math/tex; mode=display">\begin{aligned}
& 47=30*1+17 \\
& 30=17*1+13 \\
& 17=13*1+4 \\
& 13=4*3+1 \\
\end{aligned}</script><p>把余数移到左边</p>
<script type="math/tex; mode=display">\begin{aligned}
& 17=47+30*(-1) \\
& 13=30+17*(-1) \\
& 4=17+13*(-1) \\
& 1=13+4*(-3) \\
\end{aligned}</script><p>从 $\gcd(47,30)=1$ 开始，将四个式子依次带入，得</p>
<script type="math/tex; mode=display">\begin{aligned} & \gcd(47,30) \\ & =1 \\ & =13*1+4*(-3) \\ & =13*1+[17+13*(-1)]*(-3) \\ & =13*4+17*(-3) \\ & =17*3+13*4 \\ & =17*3+[30+17*(-1)]*4 \\ & =17*(-7)+30*4 \\ & =30*4+17*(-7) \\ & =30*4+[47+30*(-1)]*(-7) \\ & =30*11+47*(-7) \\ & =47*(-7)+30*11 \\ \end{aligned}</script><p>解得 $x=-7,y=11$。</p>
<p>由上述式子可观察到，每次辗转交换了 <code>x</code> 和 <code>y</code>，并将 <code>y</code> 减去了原 <code>x</code> 与辗转相除所得商的乘积。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> g, <span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">        x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">        g = a;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">exgcd</span>(b, a % b, g, y, x);</span><br><span class="line">        y -= x * (a / b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Eratosthenes-筛法"><a href="#Eratosthenes-筛法" class="headerlink" title="Eratosthenes 筛法"></a>Eratosthenes 筛法</h3><p>在筛选之前，先认为每个数都是素数。枚举所有数，如果这个数是素数，那么筛掉这个数的所有倍数，标记它们为“不是素数”。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> isNotPrime[MAXN + <span class="number">1</span>];</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; primes;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">getPrimes</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isNotPrime[i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i * <span class="number">2</span>; j &lt;= n; j += i) isNotPrime[j] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    primes.<span class="built_in">reserve</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) <span class="keyword">if</span> (!isNotPrime[i]) primes.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两个优化：</p>
<ol>
<li>第二层循环可以从 $i^2$ 开始，因为对于每个小于 $i$ 的数 $i’$，$i*i’$ 都已经在第 $i’$ 次循环筛掉了。</li>
<li>枚举 $[2,\sqrt{n}]$ 的素数即可，因为对于每个合数 $p&gt;\sqrt{n}$，则必有素数 $k$ 满足 $p=k*k’$ 且 $k&lt; \sqrt{n}$，所以 $p$ 会在第 $k$ 次循环被筛掉。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> isNotPrime[MAXN + <span class="number">1</span>];</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; primes;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">getPrimes</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m = <span class="built_in">floor</span>(<span class="built_in">sqrt</span>(n + <span class="number">0.5</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isNotPrime[i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i * i; j &lt;= n; j += i) isNotPrime[j] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    primes.<span class="built_in">reserve</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) <span class="keyword">if</span> (!isNotPrime[i]) primes.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h3><p>根据唯一分解定理，任何一个正整数 $n$ 都可以写成 $k$ 个素数的幂的积的形式，其中第 $i$ 个素数的指数为 $a_i$。即：</p>
<script type="math/tex; mode=display">n={\prod_{i=1}^{k}} \ {p_i}^{a_i}</script><p>根据容斥原理，从总数 $n$ 中先减去每个 $p_i$ 的倍数，再把多减的补回来，再把多补的减回来 …… 最终得到公式</p>
<script type="math/tex; mode=display">\phi(n)={\sum_{S{\subseteq}\{p_1,p_2,\ldots,p_k\}}{(-1)^{|S|}} * {\frac{n}{ {\prod_{ {p_i}{\in}S} } \ p_i }}}</script><p>把求和和容斥原理的应用全部展开之后就是</p>
<script type="math/tex; mode=display">\phi(n)=n*\prod_{i=1}^{k} (1 - \frac{1}{p_i})</script><p>程序实现就是先令结果为 $n$，每次把结果除掉一个 $p$ 再乘上 $p-1$。嗯，不是很好理解 ……</p>
<p>对于给定的 $n$，用类似筛法的思想枚举素数，每次找到一个素数后把它的倍数全部筛掉。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">phi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m = <span class="built_in">floor</span>(<span class="built_in">sqrt</span>(n + <span class="number">0.5</span>)), ans = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">            ans = ans / i * (i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span> (n % i == <span class="number">0</span>) n /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n != <span class="number">1</span>) ans = ans / n * (n - <span class="number">1</span>); <span class="comment">// 前面没筛干净的</span></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>未完待续 ……</p>
]]></content>
      <categories>
        <category>数论学习笔记</category>
      </categories>
      <tags>
        <tag>Eratosthenes筛法</tag>
      </tags>
  </entry>
  <entry>
    <title>图论小技巧及其扩展</title>
    <url>/2023/05/06/%E5%9B%BE%E8%AE%BA%E5%B0%8F%E6%8A%80%E5%B7%A7%E5%8F%8A%E5%85%B6%E6%89%A9%E5%B1%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>图论，其实是数学的一门分支，它以图为研究对象。最基础的图论应该是著名的哥尼斯堡七桥问题，那是一个经典的一笔画问题。</p>
<p>竞赛中我们比较常见的是 <strong>最短路算法 最小生成树算法 拓扑排序</strong> 等等。</p>
<p>本篇文章我们不说那些大家都懂烂了的图论算法，讲一些实用的 <del>(没什么用的)</del> 图论小技巧。</p>
<span id="more"></span>
<h2 id="链式前向星存图"><a href="#链式前向星存图" class="headerlink" title="链式前向星存图"></a>链式前向星存图</h2><p>最最基础的存图的基本分为两种，使用二维数组和使用 vector ，但这两种方法都有所缺陷。</p>
<p>使用二维数组查询速度很快，但空间复杂度是 O(n^2) 的，一般的题目都接受不了。</p>
<p>使用 vector 可以减少空间复杂度，但是时间就比较不确定了。</p>
<p>所以就出现了一种神奇的存图方式，<strong>链表思想的链式前向星</strong>。</p>
<p>我们通常使用以下数组来完成</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> w[i]<span class="comment">//第 i 条边的权值</span></span><br><span class="line"><span class="type">int</span> to[i]<span class="comment">//第 i 条边的终点</span></span><br><span class="line"><span class="type">int</span> nxt[i]<span class="comment">//下一条的边的编号，不建议叫 next，会挂</span></span><br><span class="line"><span class="type">int</span> head[i]<span class="comment">//以 i 为起始点的第一条边</span></span><br><span class="line"><span class="type">int</span> tot<span class="comment">//边的编号</span></span><br></pre></td></tr></table></figure>
<p>新增加一条边的时候我们进行如下操作</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> z)</span></span>&#123;</span><br><span class="line">    tot++;<span class="comment">//新边的编号</span></span><br><span class="line">    to[tot]=y;<span class="comment">//新一条边的信息</span></span><br><span class="line">    w[tot]=z;</span><br><span class="line">    nxt[tot]=head[x];</span><br><span class="line">    head[x]=tot;<span class="comment">//更新以 x 为起始点的第一条边</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这样是单向边，双向边要再来一次</span></span><br></pre></td></tr></table></figure>
<p>用下面这种方式就可以枚举出所有以 xx 为起始点的边。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=nxt[i])&#123;<span class="comment">// i 即为该边编号</span></span><br><span class="line">    <span class="comment">//to[i]为可以到达的点头</span></span><br><span class="line">    <span class="comment">//w[i]为这条边的权值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大致思想就是将所有以  x  为起始点的边以链表的形式储存，枚举的时候遍历链表，直到边的编号为 0 (为 0 表示没有其他的边了)</p>
<p>这样就可以满足我们从某个点遍历枚举下个点的需要。</p>
<p>前向星链表被疯狂应用在各个图论题目中，基本上是一个图论题都可以用到吧，属于非常基础的图论技能。</p>
<p><strong>需要注意的是对于双向边的题目，链式前向星的数组需要开边数的两倍，不然会 RE 。</strong></p>
<h2 id="反向建边"><a href="#反向建边" class="headerlink" title="反向建边"></a>反向建边</h2><p>对于一个有向图，某些问题中我们需要反向建边来完成操作</p>
<p>比如求其他 n 个点到 k 点的最短路。</p>
<p><del>对每个点跑一遍最短路不就好了吗？</del></p>
<p>事实上我们只需要跑一遍最短路就可以了，只需要把边反向建。</p>
<p>反向建图情况下 k 点到每个点的最短路就是正常情况下该点到 k 点的最短路。</p>
<p>例题 <a href="https://www.luogu.com.cn/problem/P1629">P1629 邮递员送信</a></p>
<p>不只是最短路问题，在遍历问题上也可以使用反向建边来完成</p>
<p>例题 <a href="https://www.luogu.com.cn/problem/P3916">P3916 图的遍历</a></p>
<p>是否需要反向建边，根据题意判断即可。</p>
<p>反向建边还可以来判断某条边是否在最短路上。</p>
<p>对于一个有向图，我们从 11 号点跑一遍正向的最短路 dis[ ] ，从 n 号点跑一遍反向的最短路 dis1[ ]<br>如果 dis[x] + w(x,y) + dis1[y] = dis[n] 那么我们就可以得出，这条边是在 1 到 n 的最短路上的。</p>
<p>当然如果是无向图的话直接跑就可以了。</p>
<h2 id="虚点连边"><a href="#虚点连边" class="headerlink" title="虚点连边"></a>虚点连边</h2><p>虚点连边是一种很有效的优化建边复杂度的方式</p>
<p>我们可能会遇见这样一种题，给你几个点，其他的点离这些给出的点的最近距离是多少。</p>
<p>我们可以对于每一个点进行 Spfa，但似乎这样并不是很好操作。</p>
<p>我们可以自己给出一个点，然后向每个被标记的点连一条单向边，这样就只需要进行一次 Spfa 就可以了。</p>
<p>举个例子，橙色为标记点，数字为最近距离。</p>
<p><img src="https://z4a.net/images/2019/02/25/k1ef821096fa7bd112.png" alt=""></p>
<p>例题 <a href="https://www.luogu.com.cn/problem/P3393">P3393 逃离僵尸岛</a></p>
<p>但似乎这个直接广搜也可以。</p>
<p>如果对于两个点集 A 和 B，你需要对 A 中的每一个点向 B 中的每一个点都建一条边，如果直接操作，复杂度很明显是 O(n^2) 的，有没有更快的方法呢？</p>
<p>我们可以建一个虚点 P ，然后对 A 里的每一个点向 P 连一条单向边边，然后对 P 向 B 中的每一个点建一条单向边，这样只需要 O(2n) 的复杂度就可以完成了。</p>
<p>画个图理解一下。</p>
<p>(优化前)</p>
<p><img src="https://z4a.net/images/2019/02/25/k2.png" alt=""></p>
<p>(优化后)</p>
<p><img src="https://z4a.net/images/2019/02/25/k3.png" alt=""></p>
<p>例题 <a href="https://www.luogu.com.cn/problem/P1983">P1983 车站分级</a></p>
<p>虚点连边只是听起来很高大上的操作，但实际上很简单。</p>
<p>对于有边权的情况，虚点连得边的边权需要注意(一般为 0 )</p>
<h2 id="线段树优化建边"><a href="#线段树优化建边" class="headerlink" title="线段树优化建边"></a>线段树优化建边</h2><p>说到优化建边，就一定要介绍一下线段树优化建边了。</p>
<p>这也是一个听起来非常高大上但实际上不是很难的技巧。</p>
<p>给你一个点 X ，让你和一个点集里的每一个点都连一条边。看起来并没有什么好方法，只能乖乖地一个一个连</p>
<p>如果这个点集是连续的呢？我们就可以用线段树来优化建边了。</p>
<p>我们知道线段树是这个结构的</p>
<p><img src="https://z4a.net/images/2019/02/25/k4.png" alt=""></p>
<p>我们知道，线段树的点是能够代表一段区间的，那么我们怎样应用这个性质呢？</p>
<p>首先，我们需要对于线段树的每个父亲与他的儿子建一条单向边，效果如下 </p>
<p><img src="https://z4a.net/images/2019/02/25/k5.png" alt=""></p>
<p>这有什么用呢？因为我们所要求的点集是一段连续的区间，而线段树的结点可以表示某一段区间，我们可以在线段树上找到对应的区间，然后向线段树上的点建边，就可以加快建边速度了。</p>
<p>例如我们要向 [1,8] 里的所有点建边，我们只需要将 X 和线段树上 [1,8] 那个点连一条单向边就可以了。</p>
<p>[2,6] 的例子</p>
<p><img src="https://z4a.net/images/2019/02/25/k6.png" alt=""></p>
<p>我们在线段树上的边边权一般都是 0 ，边权直接赋给 X 连到线段树上的那条边即可</p>
<p>建树和寻找的代码和普通线段树差不多。需要注意的是线段树上结点的编号不要和已有的点重复，最后的结点直接连上该点就好。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> &amp;p,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        p=l;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    p=++cnt;<span class="comment">//点的编号</span></span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(lc[p],l,mid);<span class="built_in">build</span>(rc[p],mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="built_in">add</span>(lc[p],p,<span class="number">0</span>);<span class="built_in">add</span>(rc[p],p,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> L,<span class="type">int</span> R,<span class="type">int</span> z)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L&lt;=l &amp;&amp; r&lt;=R)&#123;</span><br><span class="line">        <span class="built_in">add</span>(x,p,z);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(L&lt;=mid)&#123;</span><br><span class="line">        <span class="built_in">update</span>(lc[p],l,mid,x,L,R,z);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(R&gt;mid) &#123;</span><br><span class="line">        <span class="built_in">update</span>(rc[p],mid+<span class="number">1</span>,r,x,L,R,z);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>例题 <a href="https://www.luogu.org/problemnew/show/CF786B">CF786B Legacy</a></p>
<p>这道题还涉及到了区间向某一个点连边的情况，我们再建一个棵线段树在树上反向建边就可以了</p>
<h2 id="拆点构图"><a href="#拆点构图" class="headerlink" title="拆点构图"></a>拆点构图</h2><p>有些时候我们并不能用一个点来代表一个点（雾）</p>
<p>诶我不是这个意思。我的意思是用几个点来表示一个点的不同情况。</p>
<p>随机口胡的一道题</p>
<p>一个图，每条边上有 k 个权值，第 i 次行走消耗的代价是第 i\%k+1 个权值，求某一个点的单源最短路径。 ( k很小)</p>
<p>看起来直接跑 dij 和 spfa 是不对的，可以自举反例。</p>
<p>可以使用 dfs ，用 dis[i][j] 表示到第 i 个点走了 m 步且 m\%k+1=j 的最短方案，但这样太慢了。</p>
<p>我们可以使用拆点的思想，对于一个点 i ，将它拆为 i , i+n , i+2*n , … 这样的 k 个点，作为到这个点的步数模 k 不同情况的替代点。</p>
<p>然后我们连边的时候对某一种情况赋不同情况的权值，大概下面这样？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//我们要对 x 到 y 连三种边 w1 w2 w3</span></span><br><span class="line"><span class="built_in">add</span>(x,y+n,w1);</span><br><span class="line"><span class="built_in">add</span>(x+n,y+<span class="number">2</span>*n,w2);</span><br><span class="line"><span class="built_in">add</span>(x+<span class="number">2</span>*n,y,w3);</span><br></pre></td></tr></table></figure>
<p>来一张图</p>
<p><img src="https://z4a.net/images/2019/02/25/k7.png" alt=""></p>
<p>然后在得到的图上跑最短路就可以了，答案要枚举到终点的情况。</p>
<p>类似的例题 <a href="https://www.luogu.org/problemnew/show/P4568">P4568 飞行路线</a></p>
<h2 id="图论建模"><a href="#图论建模" class="headerlink" title="图论建模"></a>图论建模</h2><p>似乎……一些背包问题可以用最短路解决，只是没什么必要。</p>
<h3 id="Let-us-AC-it—题面"><a href="#Let-us-AC-it—题面" class="headerlink" title="Let us AC it—题面"></a>Let us AC it—题面</h3><p>Kodak开了一家小店赚外快，因为店小，所以只有 n 种不同价格的商品卖，不过好在批发商给力，货源充足，所以每种商品都有无限件。</p>
<p>因为各种原因，有时候顾客会对购买的总价有特殊的要求，比如计算机科学家泰玛仕一定要总价 1024 ，给小姐姐买礼物的面包需要总价 520 或者 1314 ，或者纯粹来找茬的张三要买0元商品</p>
<p>但是Kodak店里不一定有 1 元的商品，所以并不是所有价格都凑得出来，所以他需要一个程序解决能知道某一个总价能否凑出</p>
<p>看起来可以用完全背包解决这个问题，但是这道题的数据范围不太友好。</p>
<p>商品数 N &lt;= 1000  \  商品价格 a_i &lt;= 20000<br>顾客数 M &lt;= 300000  \ 需求价格 b_i &lt;= 40000000</p>
<p>如果打完全背包，复杂度会爆炸。TAT</p>
<p>其实这个问题就是 a_1<em>x_1+a_2</em>x_2+a_3*x_3+…?=k 的问题。我们考虑 “同余 + 最短路”</p>
<p>依题意得，如果 k 满足要求，那么 a_m<em>k 必定也满足条件。我们可以先给它填一堆 a_m ，然后减去 p 个 a_m ，用剩下的 a_i 表示 p</em>a_m+k\%a_m 设当 b\%a_m=i时，需要的最小的 k×a_m+i 为 dis[i] ，剩下的即可用最短路的思想来更新，</p>
<p>跑最短路的过程基本如下<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dis));</span><br><span class="line">dis[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">    <span class="type">int</span> x=q.<span class="built_in">top</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">if</span>(v[x]) <span class="keyword">continue</span>;</span><br><span class="line">    v[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> y=(x+a[i])%mod;</span><br><span class="line">        <span class="keyword">if</span>(dis[y]&gt;dis[x]+a[i])&#123;</span><br><span class="line">            dis[y]=dis[x]+a[i];</span><br><span class="line">            q.<span class="built_in">push</span>(y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可能不是太好理解，结合样例手推一下吧</p>
<h3 id="又一道例题"><a href="#又一道例题" class="headerlink" title="又一道例题"></a>又一道例题</h3><p>给出 n 个 长度为 m 的 01 串，让你确定一个长度相同的 01 串，该串和给出的串中不同的位数最多。</p>
<p>一道看起来跟图论毫无关系的题，其实也可以当作图论来做</p>
<p>我们可以建一个 2^m 的图，每个点都与和自身不同位数为 1 的点连一条长度为 1 的边，然后跑 bfs，得到最远距离的那个点即为所求。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(h&lt;=t)&#123;</span><br><span class="line">    <span class="type">int</span> x=v[h];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> z=x^(<span class="number">1</span>&lt;&lt;(i<span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">if</span>(f[z]==<span class="number">0</span>)&#123;</span><br><span class="line">            f[z]=<span class="number">1</span>;</span><br><span class="line">            t++;</span><br><span class="line">            v[t]=z;</span><br><span class="line">            dis[z]=dis[x]+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    h++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这有点类似于前面讲的虚点连边的那道题。</p>
<p>我讲的可能比较菜，可以画图理解。</p>
<h2 id="图论中要注意的坑"><a href="#图论中要注意的坑" class="headerlink" title="图论中要注意的坑"></a>图论中要注意的坑</h2><p>简单列述几个小问题</p>
<ol>
<li><p>先看眼是有向图还是无向图，无向图数组开两倍。</p>
</li>
<li><p>如果题目中没有声明无自环和重边，需要注意</p>
</li>
<li><p>有些遍历的题要考虑环，否则可能死循环，可以使用缩点</p>
</li>
<li><p>如果题目中边权小于等于零，要考虑负环、零环的情况</p>
</li>
<li><p>跑最短路的时候要赋初值。</p>
</li>
<li><p>关于 Spfa ，能不用还是不用吧，毕竟容易被卡。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>图论学习笔记</category>
      </categories>
      <tags>
        <tag>链式前向星</tag>
        <tag>反向建边</tag>
        <tag>虚点连边</tag>
        <tag>线段树优化建边</tag>
        <tag>拆点构图</tag>
        <tag>图论建模</tag>
      </tags>
  </entry>
  <entry>
    <title>浅析数论--埃氏筛/欧拉筛/杜教筛</title>
    <url>/2018/01/24/%E6%B5%85%E6%9E%90%E6%95%B0%E8%AE%BA-%E5%9F%83%E6%B0%8F%E7%AD%9B-%E6%AC%A7%E6%8B%89%E7%AD%9B-%E6%9D%9C%E6%95%99%E7%AD%9B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><center>质数的判定试除法 or 六倍原理、埃氏筛(稍加优化版的筛法)、线性筛</center>

<span id="more"></span>
<h2 id="0x01-绪论"><a href="#0x01-绪论" class="headerlink" title="0x01 绪论"></a>0x01 绪论</h2><h3 id="质数的判定试除法-or-六倍原理"><a href="#质数的判定试除法-or-六倍原理" class="headerlink" title="质数的判定试除法 or 六倍原理"></a>质数的判定试除法 or 六倍原理</h3><p>一个合数的约数总是成对出现的，如果  d|n  (  d  能被  n  整除），那么  (n/d)|n  ，因此我们判断一个数是否为质数的时候，<br>只需要判断较小的那一个数能否整除n就行了，即只需枚举  d&lt;=(n/d)  ，即  d&lt;=n  ，  d&lt;=sqrt(n)  就行了。</p>
<p>为何不用  sqrt()  ？请自行百度“  sqrt()  的运算方式”。你就会知道他是一个很慢的函数。</p>
<h4 id="试除法判断素数"><a href="#试除法判断素数" class="headerlink" title="试除法判断素数"></a>试除法判断素数</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_prime</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= x / i; i ++ )<span class="comment">//核心代码</span></span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="试除法分解质因数（唯一分解定理）"><a href="#试除法分解质因数（唯一分解定理）" class="headerlink" title="试除法分解质因数（唯一分解定理）"></a>试除法分解质因数（<a href="https://baike.baidu.com/item/%E7%AE%97%E6%9C%AF%E5%9F%BA%E6%9C%AC%E5%AE%9A%E7%90%86/10920095?fromtitle=%E5%94%AF%E4%B8%80%E5%88%86%E8%A7%A3%E5%AE%9A%E7%90%86&amp;fromid=23680898&amp;fr=aladdin">唯一分解定理</a>）</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">divide</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= x / i; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (x % i == <span class="number">0</span>) x /= i， s ++ ;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">1</span>) cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="一个合数分解而成的质因数最多只包含一个大于-sqrt-n-的质因数。"><a href="#一个合数分解而成的质因数最多只包含一个大于-sqrt-n-的质因数。" class="headerlink" title="一个合数分解而成的质因数最多只包含一个大于 sqrt(n)  的质因数。"></a>一个合数分解而成的质因数最多只包含一个大于 sqrt(n)  的质因数。</h4><blockquote>
<p>反证法，若 n 可以被分解成两个大于 sqrt(n) 的质因数，则这两个质因数相乘的结果大于 n ，与事实矛盾</p>
</blockquote>
<h4 id="当枚举到某一个数-i-的时候，-n-的因子里面已经不包含-2-i-1-里面的数，"><a href="#当枚举到某一个数-i-的时候，-n-的因子里面已经不包含-2-i-1-里面的数，" class="headerlink" title="当枚举到某一个数  i  的时候，  n  的因子里面已经不包含  2-i-1  里面的数，"></a>当枚举到某一个数  i  的时候，  n  的因子里面已经不包含  2-i-1  里面的数，</h4><p>如果  n%i==0  ，则  i  的因子里面也已经不包含  2-i-1  里面的数，因此每次枚举的数都是质数.</p>
<h4 id="算数基本定理-唯一分解定理-任何一个大于1的自然数-N-，如果-N-不为质数，那么-N-可以唯一分解成有限个质数的乘积"><a href="#算数基本定理-唯一分解定理-任何一个大于1的自然数-N-，如果-N-不为质数，那么-N-可以唯一分解成有限个质数的乘积" class="headerlink" title="算数基本定理(唯一分解定理):任何一个大于1的自然数  N  ，如果  N  不为质数，那么  N  可以唯一分解成有限个质数的乘积"></a>算数基本定理(唯一分解定理):任何一个大于1的自然数  N  ，如果  N  不为质数，那么  N  可以唯一分解成有限个质数的乘积</h4><p>N=P_1 * a_1P2a2P3a3……Pnan ，这里  P1&lt;P2&lt;P3……&lt;Pn  均为质数，其中指数  ai  是正整数。<br>这样的分解称为   N   的标准分解式。最早证明是由欧几里得给出的，由陈述证明。<br>此定理可推广至更一般的交换代数和代数数论。</p>
<p>质因子（或质因数）在数论里是指能整除给定正整数的质数。根据算术基本定理，不考虑排列顺序的情况下，</p>
<p>每个正整数都能够以唯一的方式表示成它的质因数的乘积。</p>
<p>两个没有共同质因子的正整数称为互质。因为  1  没有质因子，  1  与任何正整数（包括  1  本身）都是互质。</p>
<p>只有一个质因子的正整数为质数。</p>
<h2 id="质数筛法"><a href="#质数筛法" class="headerlink" title="质数筛法"></a>质数筛法</h2><h3 id="朴素筛法"><a href="#朴素筛法" class="headerlink" title="朴素筛法"></a>朴素筛法</h3><h4 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h4><p>把 2~(n-1) 中的所有的数的倍数都标记上，最后没有被标记的数就是质数.</p>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>假定有一个数  p  未被  2~(p-1)  中的数标记过，那么说明，不存在  2~(p-1)  中的任何一个数的倍数是  p  ，也就是说  p  不是  2~(p-1)  中的任何数的倍数，也就是说  2~(p-1)  中不存在p的约数，因此，根据质数的定义可知:<code>p是质数</code></p>
<h4 id="调和级数"><a href="#调和级数" class="headerlink" title="调和级数"></a>调和级数</h4><p>当  n  趋近于正无穷的时候，  1/2+1/3+1/4+1/5+…+1/n=lnn+c  .(  c  是欧阳常数，约等于  0.577  左右)</p>
<h4 id="底数越大，-log-数越小"><a href="#底数越大，-log-数越小" class="headerlink" title="底数越大，  log  数越小"></a>底数越大，  log  数越小</h4><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>约为  O(nlogn)  (注:此处的  log  数特指以 2 为底的  log  数).</p>
<h3 id="埃氏筛-稍加优化版的筛法"><a href="#埃氏筛-稍加优化版的筛法" class="headerlink" title="埃氏筛(稍加优化版的筛法)"></a>埃氏筛(稍加优化版的筛法)</h3><h4 id="质数定理"><a href="#质数定理" class="headerlink" title="质数定理"></a>质数定理</h4><p>1~n  中有  n / ln(n)  个质数</p>
<h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>在朴素筛法的过程中只用质数项去筛</p>
<h4 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>粗略估计:  O(n)  实际:  O(nlog(logn)) </p>
<p>1~n  中，只计算质数项的话，  “1/2+1/3+1/4+1/5+…+1/n”  的大小约为  log(logn)  </p>
<h3 id="线性筛"><a href="#线性筛" class="headerlink" title="线性筛"></a>线性筛</h3><p>若  n  在  10  的  6  次方的话，线性筛和埃氏筛的时间效率差不多，若  n  在  10  的  7  次方的话，线性筛会比埃氏筛快了大概一倍.</p>
<blockquote>
<p>思考:一:线性筛法为什么是线性的?<br>二:线性筛法的原理是什么?</p>
</blockquote>
<h4 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h4><p>1~n  内的合数  p  只会被其最小质因子筛掉.</p>
<h4 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h4><p>1~n  之内的任何一个合数一定会被筛掉，而且筛的时候只用最小质因子来筛，<br>然后每一个数都只有一个最小质因子，因此每个数都只会被筛一次，因此线性筛法是线性的.</p>
<p>枚举到  <code>i</code>  的最小质因子的时候就会停下来，即 <code>if(i%primes[j]==0) break;</code><br>因为从小到大枚举的所有质数，所以当 <code>i%primes[j]!=0</code> 时， <code>primes[j]</code> 一定小于  <code>i</code>  的最小质因子，<code>primes[j]</code> 一定是 <code>primes[j]*i</code> 的最小质因子.<br>因为是从小到大枚举的所有质数，所以当<code>i%primes[j]==0</code>时，<code>primes[j]</code>一定是   <code>i</code>  的最小质因子，<br>而 <code>primes[j]</code> 又是 <code>primes[j]</code> 的最小质因子，因此 <code>primes[j]</code> 是 <code>i * primes[j]</code> 的最小质因子.</p>
<h4 id="关于-for-循环的解释"><a href="#关于-for-循环的解释" class="headerlink" title="关于  for  循环的解释"></a>关于  for  循环的解释</h4><p>注:首先要把握住一个重点:我们枚举的时候是从小到大枚举的所有质数</p>
<p>1.当 <code>i%primes[j]==0</code> 时，因为是从小到大枚举的所有质数，所以 <code>primes[j]</code> 就是i的最小质因子，而 <code>primes[j]</code> 又是其本身<br><code>primes[j]</code>的最小质因子，因此当 <code>i%primes[j]==0</code> 时， <code>primes[j]</code> 是 <code>primes[j]i</code> 的最小质因子.</p>
<p>2.当 <code>i%primes[j]!=0</code> 时，因为是从小到大枚举的所有质数，且此时并没有出现过有质数满足 <code>i%primes[j]==0</code> ，<br>因此此时的 <code>primes[j]</code> 一定小于 <code>i</code> 的最小质因子，而 <code>primes[j]</code> 又是其本身 <code>primes[j]</code> 的最小质因子，<br>所以当 <code>i%primes[j]!=0</code> 时， <code>primes[j]</code> 也是 <code>primes[j]i</code> 的最小质因子.</p>
<p>3.综合1，2得知，在内层  for  循环里面无论何时， <code>primes[j]</code> 都是 <code>primes[j]i</code> 的最小质因子，因此 <code>st[primes[j]i]=true</code><br>语句就是用<code>primes[j]i</code>这个数的最小质因子来筛掉这个数.</p>
]]></content>
      <categories>
        <category>算法学习笔记</category>
      </categories>
      <tags>
        <tag>埃氏筛</tag>
        <tag>欧拉筛</tag>
        <tag>杜教筛</tag>
      </tags>
  </entry>
  <entry>
    <title>读书笔记--“所赖君子见机，达人知命”</title>
    <url>/2023/05/18/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%9D%A8%E4%BF%AE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>当我的思绪飘移到杨修时，我仿佛能够看到一条横亘在我和他之间的大河——漫天黄沙飞舞，一条大河从不知处来，往不知处走，而我和杨修便在一片历史的烟尘中面对面伫立在河的两岸。我细细地审视着他的一生，从起到落，尽看的是得意、彷徨、自信和无奈。</p>
<span id="more"></span>
<p>杨修的一生，仿佛可以化作一声叹息，叹的是千百年来书生文臣们的建业梦、救国梦。他们一直在求索，也一直在彷徨。正如《滕王阁序》里所言，“所赖君子见机，达人知命”——“时运不齐，命途多舛”自是大多数书生意气的真实写照，而真正功成名就、名留青史的，</p>
<p>正是那些“穷且益坚，不坠青云之志”的志士——但谁又能向天、向自己许诺成为一个志士呢？失意、绝望、彷徨、无奈，总让被裹挟在历史长河里的一位位英俊之才不知究竟该去往何处。千古以来，多少才俊的一生，似乎都可以被概括成现实主义和理想主义的碰撞，让人叹惋。</p>
<p>而当我在河这边叹杨修时，杨修又是否会在对岸叹我呢？我渐渐意识到，“我叹杨修”和“杨修叹我”之间，其实是“我叹我自己”——这或许是一种文艺形式最为高妙的地方吧。它是一面镜子，当我与戏里的角色共鸣时，又何尝不是在和自己共鸣？在我反思戏中角儿们的一生时，</p>
<p>又何尝不是在反思自己的一生？这种化虚为实、化无形为有形的力量，这种反思的态度、共鸣的体验，让我终于能从不同的角度审视一出戏，进而审视我的人生。人生如戏，戏如人生。从这门课上我曾学过、感受过的一切，必然会春风化雨般，散作满天星辰，陪我走完一段又一段值得我反复求索的人生之路。</p>
]]></content>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title>读书笔记--刘震云《壹句顶壹万句》</title>
    <url>/2022/11/30/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%88%98%E9%9C%87%E4%BA%91%E3%80%8A%E5%A3%B9%E5%8F%A5%E9%A1%B6%E5%A3%B9%E4%B8%87%E5%8F%A5%E3%80%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>读完整部小说，宛如读完了一部普通人的史诗。荡气回肠，平易中见深远。一个圈，一条线，在我看来，便是这本书想要通过“生活”让我们聆听的奥秘。但实际上也不是奥秘，因为它们从始至终都弥散在生活的每一个角落里。</p>
<center>你只需要侧耳倾听，它们，一直都在。</center>

<span id="more"></span>
<h1 id="总评：一个圈、一条线"><a href="#总评：一个圈、一条线" class="headerlink" title="总评：一个圈、一条线"></a>总评：一个圈、一条线</h1><p>“平易”，来自于生活的琐碎。这部小说事无巨细地反映了上世纪建国后，小城镇市民的生活风气、精神风貌。家里长、家里短；邻里关系、亲戚关系；结婚了、离婚了、拜把子了，闹掰了…书里面用极大地篇幅描述生活中一丝一缕的琐事，审视情节，便犹如审视一面镜子。人物市侩却鲜活、狭隘却灵动。通读下来，仔细回想下，我似乎可以回忆起那么几个人物——但也只是流掠而过而已。人总是这样。我们一生会遇到数不尽的、光怪陆离的人。但他们绝大多数都会离我们而去，徒留几分模糊的印象。</p>
<p>而“深远”，则同样来自于生活的琐碎。同样是用精彩的文艺升格去勾勒生活的琐碎，以《老友记》、《生活大爆炸》和所谓“韩剧”为代表的肥皂剧，已经在描述“固定几个人”的琐碎生活上做的足够好了。但是这部小说却并不将目光聚焦于几个人。以杨百顺为线索，这部小说串联起从河南延津到山西沁源的、一个又一个由“人”攒起来的圈子，兜兜转转、洋洋洒洒，最终又回到延津。一个人的生活，可以称之为 vlog；一家人的生活，可以称之为肥皂剧——但若将目光转移到由不同地域、不同脾性、不同命运的人组成的圈子上，这些本无交集、却被命运裹挟在一起的人，则更像是一幅媲美《清明上河图》的人间众生相。他们的欢喜悲忧，聚焦在几个离散的点上看，是常人皆有的情感；但一旦我们从宏观上观察这些人的连续性，就会发现一个惊人的事实：</p>
<p>每个人都在过属于自己的生活。</p>
<p>似乎很“废话文学”——过自己的生活？谁不都是过自己的生活？当我们单独看生活的一个片段时，我们总能总结出一些经验教训来；但当我们仔细回味一生时，我们却无法给出什么立竿见影的结论。在生活这个噪点数目趋近于正无穷的连续函数里，你分不清什么是对的、什么是错的，更看不清什么会停留片刻、什么会亘驻永恒。生活就像薛定谔的老猫，你不走到下一秒，下一秒的可能性，就永远不会坍缩成逻辑上的唯一。</p>
<p>生活永远是最好的老师，是只可意会、不可言传的老师。因为生活永远是整体不可积，但处处都可导。当我们追求生活的“终极奥义”时，当我们尝试用言语和智慧去分析生活中的每一处细枝末节时，最终永远只能回归到生活本身。正如书中人物命运般地从河南到山西、又从山西回到河南，正如我们尝试从生活中提炼智慧，而最终提炼出来的却是生活本身。生活教给我们的，是在“命定”和“无奈”背后的、一些更为灵巧美妙的东西。我们在复杂的生活中感叹、奔波；而当我们回过头来看时，一切选择导致的结果、一切故事最终的结局，却又都那么清晰。我们遇到的所有人、经历的所有事，仿佛飞鸿一样纷纷流掠我们的脑海，最终留下一长长的叹息。我们用一声叹息引出对生活的思考，而这思考也最终回归于对生活的叹息，回归于一个精致而简练的圈。</p>
<p>正如吴摩西是串联起从河南到山西这个“圈”的“线”，这本书也从始至终都在探讨一个线索式的问题：生活的尽头，是归于热烈还是孤独？</p>
<p>作者的答案是孤独。看似是在抨击热烈，实则是在质疑永恒。我们人生的每个阶段，似乎总有一两个能说“体己话”的 ta。但平凡生活中的平凡关系，从来都有一个未曾言明的保质期。即使是相濡以沫或高山流水，对面也很难明白你的心意。我们的孤独，终将由我们自己背负。</p>
<p>“月有阴晴圆缺，此事古难全”。我们似乎永远在追求完满，却又永远达不到完满。而孤独便是不完满投射在情感上的常态。孤独从来不是完满，因为孤独从来都是悲伤的情感，是情绪上的隔离。我们的一生永远在追逐完满，背后的事实便是一直在守候既定的不完满，这也决定了完满的尽头一定是不完满、热烈的尽头一定是孤独。贯穿在生活这个圈里的，始终是一条从热烈到孤独的单程线。</p>
<blockquote>
<h2 id="编者按-一句胜过千年"><a href="#编者按-一句胜过千年" class="headerlink" title="编者按: 一句胜过千年"></a>编者按: 一句胜过千年</h2><p>安波舜</p>
<p>本书是刘震云酝酿创作了三年的小说。也是他迄今最成熟最大气的作品。<br>小说的叙事风格类似明清的稗野日记，语句洗练，情节简洁，叙事直接，有汪曾祺和孙犁等前辈作家遗风。因而本书的每一个字每一句话，都构成言说的艺术，都能拧出作家的汗水。更为重要的是，作家唯有用此语言，才有对应和表现作品的内涵：与神对话的西方文化和人类生态，因为神的无处不在而愉悦自在。人与人之间虽说来往不多，但并不孤独；与人对话的中国文化和浮生百姓，却因为极端注重现实和儒家传统，由于其社群、地位和利益的不同，由于其人心难测和诚信缺失，能够说贴心话、温暖灵魂的朋友并不多，反倒生活在千年的孤独当中。<br>这样的孤独体验每个国人都有；这样平视百姓、体恤灵魂、为苍生而歌的小说自“五四”以来却是少有的。<br>小说的前半部写的是过去：孤独无助的吴摩西失去唯一能够“说得上话”的养女，为了寻找，走出延津；小说的后半部写的是现在：吴摩西养女的儿子牛爱国，同样为了摆脱孤独寻找“说得上话”的朋友，走向延津。一出一走，延宕百年。小说中所有的情节关系和人物结构，所有的社群组织和家庭和谐，乃至于性欲爱情，都和人与人能不能对上话，对的话能不能触及心灵、提供温暖、化解冲突、激发情欲有关。话，一旦成了人与人唯一沟通的东西，寻找和孤独便伴随一生。心灵的疲惫和生命的颓废，以及无边无际的茫然和累，便如影随形地产生了。<br>由此，我们忽然发现，中国人为什么活得这么累。<br>这种累，犹如漫漫长夜，祖祖辈辈磨砺着我们的神经。</p>
</blockquote>
<h1 id="读书笔记摘录"><a href="#读书笔记摘录" class="headerlink" title="读书笔记摘录"></a>读书笔记摘录</h1><h2 id="◆上部-出延津记（上）"><a href="#◆上部-出延津记（上）" class="headerlink" title="◆上部 出延津记（上）"></a>◆上部 出延津记（上）</h2><h3 id="2022-11-24-想法"><a href="#2022-11-24-想法" class="headerlink" title="2022/11/24 想法"></a>2022/11/24 想法</h3><p>为什么看榆树哭呢？因为榆树茁壮成长，灯盏却没了。</p>
<blockquote>
<p><em>老范吃了一惊，不再拦老汪：</em><br><em>“走也行啊，可我替你发愁，拖家带口的，你去哪儿呀？”</em><br>老汪：<br>“梦里娃告诉我，让我往西。”<br>老范：<br>“往西你也找不到娃呀。”<br>老汪：<br>“不为找娃，走到哪儿不想娃，就在哪儿落脚。”<br>第二天一早，老汪带着银瓶和三个孩子，离开了老范家。三个月没哭了，走时看到东家老范家门口有两株榆树，六年前来时，还是两棵小苗，现在已经碗口粗了，看着这树，老汪哭了。</p>
</blockquote>
<h2 id="◆上部-出延津记（下）"><a href="#◆上部-出延津记（下）" class="headerlink" title="◆上部 出延津记（下）"></a>◆上部 出延津记（下）</h2><h3 id="2022-11-24-想法-1"><a href="#2022-11-24-想法-1" class="headerlink" title="2022/11/24 想法"></a>2022/11/24 想法</h3><p>奇妙的人类社会。</p>
<blockquote>
<p>同来的往往有隔阂。过去相互不认识的，处着处着倒能成为朋友。</p>
</blockquote>
<h3 id="2022-11-24-想法-2"><a href="#2022-11-24-想法-2" class="headerlink" title="2022/11/24 想法"></a>2022/11/24 想法</h3><p>人间事事，事事曲折。</p>
<blockquote>
<p>这些年杨百顺经历过许多事，知道每个事中皆有原委，每个原委之中，又拐着好几道弯</p>
</blockquote>
<h3 id="2022-11-25-想法"><a href="#2022-11-25-想法" class="headerlink" title="2022/11/25 想法"></a>2022/11/25 想法</h3><p>人生就是一个机遇接着一个机遇，一次失败接着一次失败，跌宕起伏。</p>
<blockquote>
<p>杨摩西这时又变回早年的杨百顺。特别是他把在村里舞的一个“拉脸”，带到了县城的社火队里。这个“拉脸”杨家庄有，县城没有。所谓“拉脸”，就是一边提肩掀胯，一边用双手遮住脸，然后一寸一寸拉开，露出你的真面目。脸一寸一寸被拉开，杨摩西舞着没在意，却惊着了众人，齐声给他喝彩。会首老冯，本来对杨摩西没抱太大希望，临时抱佛脚，还担心他舞砸；他舞砸没啥，由于他舞砸，把整个社火都耽误了，事就大了。谁知这小子一上场，不但社火舞得好，竟改变了大家对阎罗的看法。一天社火舞下来，老冯眉开眼笑，拉着杨摩西问东问西。原想着只用杨摩西一天，第二天再找合适的阎罗；其实第二天也不用找了，原来的阎罗、杂货铺掌柜老邓的肚子也好了；老邓的肚子，并不像老褚说的，肠子绞在了一起，还是蛔虫闹的；吃下老褚的药，肠子没捋顺，将蛔虫拉了出来，阴差阳错，肚子也就好了；但老冯不再理老邓，让杨摩西又舞了四天社火。</p>
</blockquote>
<h4 id="2022-11-25-想法-1"><a href="#2022-11-25-想法-1" class="headerlink" title="2022/11/25 想法"></a>2022/11/25 想法</h4><p>清官难断家务事。</p>
<blockquote>
<p>街上的事，只是一个事；家里的事，就不光是事。</p>
<p>反正与她说不明白道理，这时再计较道理，反倒是不懂道理了。</p>
</blockquote>
<h2 id="◆下部-回延津记"><a href="#◆下部-回延津记" class="headerlink" title="◆下部 回延津记"></a>◆下部 回延津记</h2><h3 id="2022-11-27-想法"><a href="#2022-11-27-想法" class="headerlink" title="2022/11/27 想法"></a>2022/11/27 想法</h3><p>平常人的感动。</p>
<blockquote>
<p>学会开汽车，我开着汽车，带姐去北京。</p>
</blockquote>
<h3 id="2022-11-27-想法-1"><a href="#2022-11-27-想法-1" class="headerlink" title="2022/11/27 想法"></a>2022/11/27 想法</h3><p>人间社交，大抵皆如此：</p>
<blockquote>
<p>“不管你到天南海北，咱俩好一辈子。”</p>
<p>五年之中，头两年两人还通信，后来渐渐淡了，后来渐渐断了。</p>
<p>可见能否成为朋友，不在相处的长短。</p>
</blockquote>
<h3 id="2022-11-27-想法-2"><a href="#2022-11-27-想法-2" class="headerlink" title="2022/11/27 想法"></a>2022/11/27 想法</h3><p>虽说人生如戏、戏如人生，但想起来是一码事、看起来是一码事，真正过起来又是另一码事。</p>
<blockquote>
<p>戏里说的事，也是世上的事，怎么戏里说的，就比世上的事有意思呢？</p>
</blockquote>
<h3 id="2022-11-28-想法"><a href="#2022-11-28-想法" class="headerlink" title="2022/11/28 想法"></a>2022/11/28 想法</h3><p>曹青娥找到年轻的初恋侯宝山时，看到他不戴白手套了，开着过去那“拉风”的拖拉机载着老婆耕地，给孩子把尿时：</p>
<blockquote>
<p>曹青娥突然明白，她找的侯宝山，不是这个侯宝山；她要找的侯宝山，在这个世界上，已经死了。</p>
<p>曹青娥这时才明白，人是掰扯不得的，掰扯了别人，就是掰扯了自己。</p>
</blockquote>
<h3 id="2022-11-28-想法-1"><a href="#2022-11-28-想法-1" class="headerlink" title="2022/11/28 想法"></a>2022/11/28 想法</h3><p>唉…</p>
<blockquote>
<p>但老曹死后三个月，曹青娥突然开始想念爹爹老曹。夜里常梦见他。这时的老曹，又变回七十岁之前的老曹，或六十岁的老曹，或五十岁的老曹，或四十多岁的老曹，或刚买曹青娥，也就是改心时的老曹。老曹用脖子驮着她，笑着在街上走，给她买吃食；或老曹趴在地上，让曹青娥当马骑。</p>
</blockquote>
<h3 id="2022-11-28-想法-2"><a href="#2022-11-28-想法-2" class="headerlink" title="2022/11/28 想法"></a>2022/11/28 想法</h3><p>和当时梦到自己把吴摩西卖给了人贩子如出一辙</p>
<blockquote>
<p>“妮，你嫁走了，谁管我呀？”<br>或：<br>“妮，牛书道那人没正性，不能嫁。”</p>
</blockquote>
<h3 id="2022-11-28-想法-3"><a href="#2022-11-28-想法-3" class="headerlink" title="2022/11/28 想法"></a>2022/11/28 想法</h3><p>历史是个圈</p>
<blockquote>
<p>与当初冯文修用牛轭砸李克智一模一样</p>
</blockquote>
<h3 id="2022-11-28-想法-4"><a href="#2022-11-28-想法-4" class="headerlink" title="2022/11/28 想法"></a>2022/11/28 想法</h3><p>曹青娥的人生智慧。</p>
<blockquote>
<p>世上烦的就是这些亲人。论起共事，用谁，都比用他们好。</p>
<p>“我活了七十岁，明白一个道理，世上别的东西都能挑，就是日子没法挑。”</p>
<p>我还看穿一件事，过日子是过以后，不是过从前。</p>
</blockquote>
<h3 id="2022-11-28-想法-5"><a href="#2022-11-28-想法-5" class="headerlink" title="2022/11/28 想法"></a>2022/11/28 想法</h3><p>通透，不自个儿过个几十年过不出来这种智慧。</p>
<blockquote>
<p>“你跟她说得着，是因为她现在由丈夫养着，你就是与她说个话；等你养她，就成了过日子，到时候就该说过日子了。”</p>
</blockquote>
<h3 id="2022-11-29-想法"><a href="#2022-11-29-想法" class="headerlink" title="2022/11/29 想法"></a>2022/11/29 想法</h3><p>所以其实儿女和父母本身虽然是互相照顾、互相爱护，但并不是互相理解。</p>
<blockquote>
<p>妈曹青娥得病三四年没说，可以说是心疼他们，但除了心疼，还有对他们的失望罢了。</p>
<p>牛爱国突然又明白，曹青娥对他说六十年前、五十年前的事情，不对牛爱江、牛爱香、牛爱河说，并不是觉得跟他比跟其他人说得来，而是他遇到的麻烦比其他人更多，借此安慰他罢了。去年牛爱国因为庞丽娜出了事，对沁源伤了心，离开沁源前去看曹青娥，曹青娥知道事情的原委，但没对牛爱国挑破；现在曹青娥不会说话了，牛爱国像去年妈对他一样，他也没将妈的心思，对哥牛爱江和姐牛爱香挑破。</p>
</blockquote>
<h3 id="2022-11-29-想法-1"><a href="#2022-11-29-想法-1" class="headerlink" title="2022/11/29 想法"></a>2022/11/29 想法</h3><p>不知道该说些什么，感觉心脏被锤了一拳。</p>
<blockquote>
<p>因为远，我才能送你。</p>
<p>知道见你不容易，才想起这么多话。</p>
<p>直到最后一班长途汽车要发车了，曹青娥才上了车。从车上往下看，空空荡荡的汽车站里，就剩下娘一个人，拄着拐杖，嘴在张着，曹青娥不禁流下了泪。</p>
<p>“妮，下次我再走的时候，就别再喊我了。娘一个月走不动道，身子是太沉了。刚才到了梦里，我走呀走呀，走到一个河边，腿突然就轻了。河边有花有草，我说，好长时间没洗脸了，蹲这河边洗把脸吧。刚要洗脸，听到你喊我，就又回来了；一回来，又躺在这病床上。妮，下次娘走的时候，就不要再喊娘了；不是娘心狠，不是娘没话跟你说，实在是受不了了……”</p>
<p>下次老曹老婆昏迷的时候，曹青娥就没有再喊娘。</p>
</blockquote>
<h3 id="2022-11-29-想法-2"><a href="#2022-11-29-想法-2" class="headerlink" title="2022/11/29 想法"></a>2022/11/29 想法</h3><p>最思念的，还是自己的根。</p>
<blockquote>
<p>曹青娥临终前在喊“爹”，原来不是喊襄垣县的爹爹老曹，而是多年前失散的爹爹吴摩西。</p>
</blockquote>
<h3 id="2022-11-29-想法-3"><a href="#2022-11-29-想法-3" class="headerlink" title="2022/11/29 想法"></a>2022/11/29 想法</h3><p>沧海桑田</p>
<blockquote>
<p>到西街一个地方，告诉牛爱国这是当年吴摩西和吴香香蒸馒头的家，现在成了一家酱菜厂；到了北街转盘处，说转盘西北角，当年是意大利神父老詹的教堂，现在成了“金盆洗脚屋”；到了东街桥下，说这里当年有吴摩西挑水的井，现在成了一个卷烟厂；回到南街，指着姜素荣杂货铺旁边的剧场，说这里当年是吴摩西大闹南街的地方，当年的一个碌碡，现在还戳在剧院门侧</p>
</blockquote>
<h3 id="2022-11-29-想法-4"><a href="#2022-11-29-想法-4" class="headerlink" title="2022/11/29 想法"></a>2022/11/29 想法</h3><p>唯有门前镜湖水，春风不改旧时波。</p>
<blockquote>
<p>七十年前，吴摩西从河南去了陕西；七十年后，牛爱国也从河南去了陕西。</p>
<p>牛爱国接过这沓纸，纸已经发黄，许多地方被虫蛀了。打开，纸上是一幅图，画着一座宏大的房子，看上去像一座教堂。教堂顶端有十字架，还有一座大钟。图画得倒是气派</p>
<p>院中有一棵大槐树，牛爱国搬一个凳子，坐在大槐树下。低头想了一阵心思，猛地抬头，一个大月亮，缺了半边，顶头在半空中。虽是半个月亮，却也亮得逼人。一阵风吹来，槐树的叶子“索索”地响；脚下树叶的影子，也随声“索索”地晃动。</p>
</blockquote>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Reading</tag>
      </tags>
  </entry>
  <entry>
    <title>读书笔记--《献给阿吉尔侬的花束》</title>
    <url>/2019/05/06/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E3%80%8A%E7%8C%AE%E7%BB%99%E9%98%BF%E5%90%89%E5%B0%94%E4%BE%AC%E7%9A%84%E8%8A%B1%E6%9D%9F%E3%80%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>《花束》这出悲剧，与其说是悲伤，不如说是悲壮。Charlie 凭自己一个人，接受了世所罕见的手术实验，体验了绝无仅有的人生落差，并为书中的“后世”留下了宝贵的精神财富。从这个意义上讲，他是一个英雄，因为他用孤独的臂膀撑起了一部人类的史诗。</p>
<span id="more"></span>
<h1 id="这是一本什么书？"><a href="#这是一本什么书？" class="headerlink" title="这是一本什么书？"></a>这是一本什么书？</h1><p>首先，《献给阿尔吉侬的花束》是一本小说，严格意义上是通俗科幻类小说，曾获得过 1960 年雨果奖最佳长篇、1966 年星云奖最佳长篇。这两个年度分别是雨果奖和星云奖的第 8 届和第 2 届，因此，《花束》也算是科幻文学领域奠基式的作品。</p>
<p>这些 title 其实足以说明本书的优秀。但其实，《花束》这本书并不算是传统意义上的“硬科幻”（如大家熟知的《三体》），甚至科学层面上也很难与一些熟知的软科幻类作品叫板（例如《降临》、《星际穿越》或是《蝴蝶效应》等）。简而言之，就是本书几乎没讨论过任何科学上的内容，或者作者其实根本没把这个当做重点。本书的科幻部分，更多的则是一座从“作者心中”架往“读者心中”的桥梁而已。</p>
<p>那这本书，又是为何而备受好评的呢？</p>
<p>当你读完这本书，就会发现《花束》的内核，其实是人文关怀。</p>
<p>本书的情节大概可以被简单地概括出来：主角 Charlie Gordon 是一个 IQ 为 68 的低智者，一直在救助中心学习。而某天，因为他认真、努力、诚恳的心态，结合众多因素，一个科学小组选中了他，并通过手术他改造成了智商飞速提高的天才。成为天才之后，他经历了很多未曾经历的事情。而最后，也因为实验本身存在的问题，他的高智商消退、大脑萎缩并撒手人寰。而书名中的“阿尔吉侬”，这是一只同样经历过手术的小鼠，和 Charlie 有着相似的宿命。而本书的标题 <em>Flowers for Algernon</em>，则来源于主角离世前的最后一句话：<code>please if you get a chance put some flowers on Algernons grave in the bak yard</code>。</p>
<p>本书的一大行文特点是通过第一人称“日志”的形式叙述，极大地丰富了感染力。主角从一开始因为智商差距、拼写出来的单词让人啼笑皆非，到智商飞跃后可以使用很长的单词、很复杂的句子，再到最后重新回归拼写错误的状态，让读者也能从另一个角度、更深刻地理解主角的变化。而这种变化极大地震撼了我的心灵（下文中会细讲）。这里先放一段英文原版（第一章），你可以通过这一部分更详细地了解到我想表达的意思。</p>
<p><img src="https://vlilac.gitee.io/images/Eng.jpg" alt="img"></p>
<p>值得注意的是，作者还比较贴心的将单词错拼成了能自然拼读出的写法，这似乎也从科学上符合“拼写功能低下症”的逻辑——毕竟生活中还是要对话的。例如第一句应该是<code>progress report 1, March 3</code>。类似的你也可以类比一下这一段到底说的什么意思。</p>
<h1 id="思考和延伸"><a href="#思考和延伸" class="headerlink" title="思考和延伸"></a>思考和延伸</h1><p>这一部分是记录我阅读的思考和一些天马行空的延伸。</p>
<h2 id="悲剧内核：毁灭和绽放"><a href="#悲剧内核：毁灭和绽放" class="headerlink" title="悲剧内核：毁灭和绽放"></a>悲剧内核：毁灭和绽放</h2><p>通读完不难发现，这篇小说的内是一出悲剧。</p>
<p>一种比较常见的解读，用一句比较网红的话来讲，是“如果我不曾见过光明，我便不会绝望于黑暗”。主角 Charlie 经历了从高智商回到低智商的过程，身为读者，读的时候确实能感受出一种绝望的气氛。Charlie 自己是如此形容的：</p>
<blockquote>
<p>我们并不属于相同层级。我在往上攀升时经过你的楼层，现在我在下降途中再次经过，但我想我不会再搭这部升降梯。所以，此时此刻就让我们相互道别。</p>
</blockquote>
<p>命定的结局，转瞬即逝的灵智。这么看来，仿佛是有点日本美学的味道：以毁灭为代价的绽放才是至高的美。本书的逻辑确实是这样的——如果 Charlie 不曾接受手术，或许就会在救助学校里度过一生，会在面包店扫一辈子的地，而不会迎来大脑萎缩的结局。但这并不是“美”的。Charlie 的变化，像极了一个普通人穷极一生换来的一个“绽放”的机会。它告诉我们了，我们的边界在哪里、人类的边界在哪里、美的边界在哪里。从刀耕火种的时代绵延至今，从部落、城邦到国家，探索生存的边界、探索生存意义的边界，一直是人类永恒求索的课题。也正因为一代又一代人薪火相传地探索，人类文明才能不断走向浩瀚的星空。</p>
<h2 id="How-to-become-a-Human"><a href="#How-to-become-a-Human" class="headerlink" title="How to become a Human?"></a>How to become a Human?</h2><p>虽然本书是悲剧内核，是“毁灭的绽放”留给人的感叹，但我其实并不认为这是书中最为重要的部分。相反，书中极大的篇幅描述 Charlie 开始飞速提高智商后的情节，才是本书的精髓所在。</p>
<p>Charlie 迅速提高智商后，似乎是变“聪明”了，但实际上他并没有活的更开心。人类社会从来不是智商主导一切的，情商、逆商等具有社交属性的、只能通过后天锻炼培养的，才是人立足于社会的核心要义。而 Charlie 显然不具有这些。所以在最初，他会把所有有关于社交的事情弄得一团糟，他会无法控制情绪。但慢慢地，随着他与社会的交流、与人的交流，他开始逐渐“成为人类”。</p>
<p>这也是我想表达的、这一小节的标题：How to become a human? 如何成为一个人类？这不仅在教育学上有重要意义，在我们个人面对人生时，也有重要的价值。这个问题等价为：用什么标准才能衡量出“人”？——是对“人”本身意义的思考。而正是围绕着这一核心问题，作者仍在叙述过程中抛出了更多值得思考的课题：什么是爱？什么是存在？人是否注定孤独？又该以怎样的态度面对死亡？</p>
<p>我无法准确回答这些问题，或者说，没人能准确回答这些问题——但人类向来擅长思考和追问没有答案的问题，这或许也是这本书的厚度所在。被赋予智商，更像是被赋予了思考这些问题的机会；拼尽所有换来的高智商，若是等效成“拼尽所有换来的入场券”，则似乎能说明一个道理：人类一直在穷尽所有，尝试去解决有关自己的问题。</p>
<p>所以，这份感动，或许不仅是来自于 Charlie 对自己生命的思考，也来自于人类文明持续不断地自我反思——一世如此，世世如斯。</p>
<h2 id="配角思考：正常人而已"><a href="#配角思考：正常人而已" class="headerlink" title="配角思考：正常人而已"></a>配角思考：正常人而已</h2><p>这本书的配角刻画无疑是非常成功的。虽然都没有很多戏份，但是作者用简练的笔触描绘出了正常人该有的样子。我在读的过程中，有时会对一些角色产生厌恶情绪。但直到读完，我发现他们只是正常人而已。</p>
<p>换句话说，配角的戏份更多的是一种对比，是 Charlie “进化”后的“神性”和配角们最为普通的“人性”的对比。Charlie 不具备道德、情感、美学上的神性，仅具有智力上的神性。他像极了一个机器人，有着超乎常人的大脑和精力，唯独少了一颗有血有肉的心。而这部分便由配角递补、完成了使命。面包店的同伴，在 Charlie 变聪明时开始排斥他，又在他变笨时毫无保留地保护他；纪尼安小姐在 Charlie 极端聪明时不得不离开他——因为在他身边会让普通人质疑自己存在的意义——而又在他“坠落”到人类智商时接受他…是的，他们只是正常人而已。</p>
<p>当这份平凡与普通，站在了达到了人类顶峰却依然痛苦的 Charlie 对面时，却显得无比高贵、无比可爱。这便是人性对神性的救赎，更是人类对自己的救赎。</p>
<h1 id="我为何深受触动？"><a href="#我为何深受触动？" class="headerlink" title="我为何深受触动？"></a>我为何深受触动？</h1><p>首先，这本书是我 2022/11/30 的夜里突然翻到的，从两点看到六点半，睡了一个小时后起来上体育课，上完体育课又回宿舍继续读，十点左右看完的（实际上体育课上我也一直在偷偷看）。</p>
<p>人们常说，一部完整的文艺作品，一定需要受众加入创作，用自己的体会、体验、思考、情感去丰富作者创造的文艺世界。是的，我认同这一点。因此，这一部分我想着重谈谈我的感受。</p>
<p>我读完有两种感受：悲伤和复杂。悲伤不再赘述，在第二节“思考与延伸”已经叙述的够多了。而复杂呢？这种复杂，无比类似于读完一部完整史诗时的复杂感受，因为这本书，其实记录了 Charlie 的一生。幼年时被当做异类，歇斯底里的母亲，不置可否的父亲，不理不睬的妹妹；成年后充实的“救助学校”生活、空虚的“智商飞跃后”生活，和最终为人类作出不计其数的伟大贡献后归于坟墓——这就是 Charlie 的一生。当我们读完一个人的一生后，便只能长叹一声。</p>
<p>这是一种极其复合的情感，我不知该如何言明。只能尝试先解构成几种基础的感情：</p>
<p>首先，孤独。Charlie 似乎一直没有幸福过，似乎一直孤独。他从低智商飞跃到高智商，又从高智商坠落回低智商：他的每一步，都远离了正常人思考能力的极限范围，要么跌出下限，要么高出上限。这也决定了，没有人能够真正理解他，孤独便是他既定的宿命。这似乎总让我想起我自己、想起我自己的孤独。果然，孤独从来都是自己为自己筑起的藩篱，外界渺小的作用力，从来都是望洋兴叹。</p>
<p>同时，佩服。我称这部小说为“史诗”，因为 Charlie 本身就是英雄式的角色。他看到了别人未曾看到的景色，也拥有了别人未曾有过的遗憾。英雄的形象，在这一刻得到了极其丰满周详的诠释。Pay more, get more.</p>
<p>最后，无奈。Charlie 的一生，又何尝不是无数个普通人的一生？我们都会有“春风得意马蹄疾，一日看尽长安花”的日子，也一定会面临滑铁卢。人生正式由一段段曲折的经历构成的。成功似乎永远只有一刹，不断更替交织的生活，会用时间魔法把一切变为历史。我们只能选择平静地接受一些痛苦折磨、平安喜乐，对此无可奈何，令人感慨叹息。</p>
<h1 id="献给阿尔吉侬的花束"><a href="#献给阿尔吉侬的花束" class="headerlink" title="献给阿尔吉侬的花束"></a>献给阿尔吉侬的花束</h1><p>最后的最后，我也希望能够有朝一日，将一束花轻轻放在和 Charlie 有着相似境遇的小鼠——阿尔吉侬的墓前。这不仅仅是在祭奠阿尔吉侬，也是在怀念 Charlie，更是在与我仍未洞悉全貌的人生，互相致意。</p>
<h1 id="读书笔记"><a href="#读书笔记" class="headerlink" title="读书笔记"></a>读书笔记</h1><p>阅读时的勾画和简单思考。</p>
<h2 id="◆-近步抱告—3"><a href="#◆-近步抱告—3" class="headerlink" title="◆ 近步抱告—3"></a>◆ 近步抱告—3</h2><p>Charlie 虽然低智，但是比绝大多数人都努力。</p>
<blockquote>
<p>纪尼安小姐告诉他我是她在比克曼学校低能成人班中最好的学生。而且我也最用功。因为我真的想要学我比那些更匆名的人还要奴力。</p>
</blockquote>
<p>同上。</p>
<blockquote>
<p>但我没有关西我跟本不怕痛或什么的。因为我很强壮而且我会很奴力。</p>
</blockquote>
<h2 id="◆-近步抱告—6"><a href="#◆-近步抱告—6" class="headerlink" title="◆ 近步抱告—6"></a>◆ 近步抱告—6</h2><p>Charlie 在低智商时，对朋友有着超乎寻常的依赖。或许这是身体本能的、对归属感和安全感的渴望。</p>
<blockquote>
<p>我才不管便有名。我只要和其他人一样便匆名。这样我就可以有很多洗欢我的朋友。</p>
</blockquote>
<h2 id="◆-进步报告—7"><a href="#◆-进步报告—7" class="headerlink" title="◆ 进步报告—7"></a>◆ 进步报告—7</h2><p>对变聪明后的生活怀揣着深切的希望，殊不知“便匆名”后并不一定会更快乐。</p>
<blockquote>
<p>匆名的人都在想什么或想以前的什么呢。我猜都是很美妙的是情。我好西望我已经知到许多美妙的是情。</p>
</blockquote>
<h2 id="◆-进步报告—8"><a href="#◆-进步报告—8" class="headerlink" title="◆ 进步报告—8"></a>◆ 进步报告—8</h2><p>哎…</p>
<blockquote>
<p>他们是我的朋友他们都洗欢我。</p>
<p>我完的很快乐。我们做游戏。他们让我头上代着灯罩在巴台上跳五。让美个人都笑起来。</p>
</blockquote>
<h2 id="◆-进步报告—9"><a href="#◆-进步报告—9" class="headerlink" title="◆ 进步报告—9"></a>◆ 进步报告—9</h2><p>这个地方其实是圈子里的女性朋友发现了大家都在欺负 Charlie，但 Charlie 依然把他们当做朋友。她去厕所哭了。</p>
<blockquote>
<p>我说我所有的朋友都很聪明。而且他们都很好。他们喜欢我。从来不会对我做不好的事情。然后有东西进去她的眼睛。她必须跑去女士的洗手间。</p>
</blockquote>
<p>拼写和语法开始变得正确</p>
<blockquote>
<p>我弄清楚标点符号的作用后，我把过去的进步报告从头读了一次。天哪，我的拼音与标点符号可真疯狂！</p>
</blockquote>
<p>Charlie 第一次发现所谓“朋友”的“笑”，其实不怀好意。</p>
<blockquote>
<p>这就是乔和其他人正在做的事，他们在嘲笑我。和我玩捉迷藏的小朋友是在作弄我，他们一样是在嘲笑我。派对上的人像是一堆向下张望的模糊面孔，每张脸都对着我嘲笑。</p>
</blockquote>
<p>有了性意识。这么看来，似乎“繁殖”这一生物的重大使命，站在自然选择的角度来讲，更倾向于智商高的人吧。</p>
<blockquote>
<p>我梦到那位和我跳舞并且在我身上搓摩的女孩艾伦，当我醒过来时，床单湿了，而且一团乱。</p>
</blockquote>
<p>模糊的记忆开始聚合。</p>
<blockquote>
<p>看到面包店所在的那条街，起初有些模糊，然后逐渐零零落落地拼凑起来，有些部分变得非常真实，现在明确地呈现在我眼前，只是其他部分依旧模糊，而我也不确定……</p>
</blockquote>
<h2 id="◆-进步报告—10"><a href="#◆-进步报告—10" class="headerlink" title="◆ 进步报告—10"></a>◆ 进步报告—10</h2><p>批判性思维的萌芽。</p>
<blockquote>
<p>现在我知道上大学和接受教育的最重要理由之一，是去了解你以前一直相信的事情并非真实，而且任何东西都不能只靠外表来决定。</p>
</blockquote>
<h2 id="◆-进步报告—11"><a href="#◆-进步报告—11" class="headerlink" title="◆ 进步报告—11"></a>◆ 进步报告—11</h2><p>理性与感性的碰撞，批判性思维的觉醒。</p>
<blockquote>
<p>但我写下这些事情时，我的内在却有个声音在对我大吼，告诉我不是如此。我是个人，在接受手术之前，就已经是个人，我必须去爱别人。</p>
</blockquote>
<p>逐渐开始理解谎言的普遍性，以及一些问题的答案如果不会带来任何好处，就不必要问。</p>
<blockquote>
<p>我再也不想知道实情。</p>
</blockquote>
<p>是的，人生中绝大多数问题都无比复杂，没有简单的解析解。</p>
<blockquote>
<p>然而，金皮只是个员工，他有三个孩子要养，如果唐纳把他开除，他要怎么办？他可能再也找不到工作，特别是他还有条畸形的腿。</p>
<p>我应该为此忧虑吗？</p>
<p>怎么做才对？讽刺的是，我所有的聪明才智也无法帮我解决这道难题。</p>
</blockquote>
<h2 id="◆-进步报告—12"><a href="#◆-进步报告—12" class="headerlink" title="◆ 进步报告—12"></a>◆ 进步报告—12</h2><p>深刻。</p>
<blockquote>
<p>讲话与书写都应该力求简单与直接，好让别人能够了解。他要我注意，语言有时是一种障碍，不是通路。说起来很讽刺，我现在竟然是落在智识藩篱的另一边。</p>
</blockquote>
<p>父亲一直把查理当作真正的“人”来看待。</p>
<blockquote>
<p>马特指着站在墙边的查理：“你忘了自己告诉过儿子，他不能养狗，因为我们空间不够，也没人能照顾狗。记得了吗？他那时候要求养狗时，你对他说的话不算数了吗？”</p>
<p>“可是我可以自己照顾我的狗，”</p>
</blockquote>
<h2 id="◆-进步报告—13"><a href="#◆-进步报告—13" class="headerlink" title="◆ 进步报告—13"></a>◆ 进步报告—13</h2><p>极端的母亲，不幸的童年。但其实母亲一开始也是怀揣希望的，逐渐被现实逼迫的歇斯底里起来…</p>
<blockquote>
<p>直到诺尔玛的出生证明她也能生出正常的孩子，我只是个异数后，她才不再想改变我。</p>
</blockquote>
<p>弥补了情感上的缺憾。</p>
<blockquote>
<p>照理说我应该痛恨他对我做的那些事，还有他利用罗丝和马特的行为，可是我无法恨他。在那第一天之后，他一直对我很好，总是拍拍我的肩膀、微笑，说些我难得听闻的鼓励话语。</p>
<p>即使在那时候，他也把我当人看待。</p>
</blockquote>
<p>对研究人员的新思考，批判而感到冒犯。</p>
<blockquote>
<p>他和其他人犯下同样的错误，他们嘲笑弱智者，因为他们不了解对方也是人类。他不能体会，我来这里之前就已经是个人。</p>
<p>所以，伯特称赞尼姆与斯特劳斯全心投入在一些重要且不确定的事物上，而不是找些安全但不重要的东西研究，他说得没有错。</p>
<p>大家谈到我时，却都把我当作某种为科学发表而创造出的东西。</p>
</blockquote>
<h2 id="◆-进步报告—14"><a href="#◆-进步报告—14" class="headerlink" title="◆ 进步报告—14"></a>◆ 进步报告—14</h2><p>是在说阿尔吉侬，也是在说 Charlie。</p>
<blockquote>
<p>它不需要食物或饮水来激发学习，它似乎是为了解决问题而学习，显然成就感就已经是种回报。</p>
</blockquote>
<p>这其实是很重要的成长过程。查理通过飞速学习建立起的认知，一定是有秩序的。但现实生活中的秩序却往往掩盖在混乱的最深层，所以学会生活，首先要学会接受混乱和无序。</p>
<blockquote>
<p>她笑我还需要锁门，我则笑她屋里的一团混乱。她警告我别想改变她</p>
<p>我从未认识像费伊这样开放并信赖别人的人，她是我此刻最需要的人，因为我一直渴盼有单纯的人际接触。</p>
</blockquote>
<h2 id="◆-进步报告—16"><a href="#◆-进步报告—16" class="headerlink" title="◆ 进步报告—16"></a>◆ 进步报告—16</h2><p>作者的思考。</p>
<blockquote>
<p>一种认命的无奈感。人们绝口不谈复健、治疗，或是把病人重新送回世界，没有人谈到希望。那种感觉就像活生生的死亡……或是更糟，根本不曾充分活着与了解。灵魂从一开始就在枯萎，并注定要对着每一天的时间与空间凝望。</p>
<p>然而，你为我做的事尽管美妙，你却没有权利可以像实验动物一样对待我。我现在是个独立的个人，但查理在走进实验室前，同样也是独立的个人。</p>
<p>如果没有人性情感的调和，智慧与教育根本毫无价值</p>
</blockquote>
<p>更高的进化历程：感性具有了对自我的批判，是自我反思的源泉。</p>
<blockquote>
<p>我低头看自己，然后看到自己真正变成的模样。我觉得羞耻。</p>
<p>讽刺的是，我们兄妹两人聊到母亲时，口气就像她不在现场，但其实她就在房间里。</p>
<p>我曾经梦想过这种时刻，此刻虽身历其境，但有什么用呢？我不能把自己即将面对的遭遇告诉她，而且，我能够接受这种出于虚假前提的亲情吗？如果我还是以前那个弱智、需要倚赖别人的查理，她势必会以不同方式和我说话。所以，我现在有什么权利可以要求呢？我的面具很快就会被撕掉。</p>
<p>这是我一直想扮演的角色……大哥。</p>
</blockquote>
<h2 id="◆-进步报告—17"><a href="#◆-进步报告—17" class="headerlink" title="◆ 进步报告—17"></a>◆ 进步报告—17</h2><p>Charlie 在坠落了…</p>
<blockquote>
<p>我们并不属于相同层级。我在往上攀升时经过你的楼层，现在我在下降途中再次经过，但我想我不会再搭这部升降梯。所以，此时此刻就让我们相互道别。</p>
<p>艾丽斯在身边的唯一坏处，是我觉得现在必须对抗这件事。我想要停下时间，把自己冻结在这个层级，绝不放她走。</p>
<p>“还有比拥有高智商更重要的事。”</p>
</blockquote>
<p>不希望恋人看到越来越差劲的自己…爱建立在了自信上，便会在自我否定时被破坏。</p>
<blockquote>
<p>不要管我，我已不是我自己。我正在解体，我不希望你在这里。</p>
</blockquote>
<p>这里的标点符号又消失了…一步一步渐次退化。</p>
<blockquote>
<p>我尽量每天读一点东西多数都是故事书但有时候我必须同样的东西读很多次因为我不懂其中的意思</p>
</blockquote>
<p>祭奠阿尔吉侬，也是在祭奠自己。</p>
<blockquote>
<p>外面已经变得寒冷但我仍然放花在阿尔吉侬的坟上。穆尼太太认为我放花在一只老鼠的坟上实在很笨但我告诉她阿尔吉侬是一只很特别的老鼠。</p>
<p>外面已经变得寒冷但我仍然放花在阿尔吉侬的坟上。穆尼太太认为我放花在一只老鼠的坟上实在很笨但我告诉她阿尔吉侬是一只很特别的老鼠。</p>
<p>我告诉他我曾经有位叫阿尔吉侬的朋友但它是一只老鼠我们经常一起比赛。</p>
<p>我想我知道我为什么运气不好。因为我丢掉了我的兔脚和马蹄铁。我必须赶快在去弄另一个兔脚。</p>
<p>有朋友真好……</p>
<p>所以我说哈罗纪尼安小姐我今天已准备好要上课只是我弄丢了我们在用的书本。<br>她开始哭起来并且跑出去教室。</p>
<p>因为我学到很多我以前甚至不知到这世界上真的存在的事情。我很高兴能够看到这些即使只是很短的时间。我很高兴我发现了所有关于我的家人和我的事。好像在我想起他们并且看过他们之前我并没有家人似的但现在我知到我有家人而且我和大家一样也是一个人。</p>
<p>如果你有机会请放一些花在后院的阿尔吉侬坟上。</p>
</blockquote>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Reading</tag>
      </tags>
  </entry>
</search>
